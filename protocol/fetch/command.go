// Code generated by cdpgen. DO NOT EDIT.

package fetch

import (
	"encoding/json"
	"log"

	"github.com/4ydx/cdp/protocol/io"
	"github.com/4ydx/cdp/protocol/network"
)

const (
	CommandFetchDisable                  = "Fetch.disable"
	CommandFetchEnable                   = "Fetch.enable"
	CommandFetchFailRequest              = "Fetch.failRequest"
	CommandFetchFulfillRequest           = "Fetch.fulfillRequest"
	CommandFetchContinueRequest          = "Fetch.continueRequest"
	CommandFetchContinueWithAuth         = "Fetch.continueWithAuth"
	CommandFetchGetResponseBody          = "Fetch.getResponseBody"
	CommandFetchTakeResponseBodyAsStream = "Fetch.takeResponseBodyAsStream"
)

// DisableArgs represents the arguments for Disable in the Fetch domain.
type DisableArgs struct {
}

// Unmarshal the byte array into a return value for Disable in the Fetch domain.
func (a *DisableArgs) UnmarshalJSON(b []byte) error {
	type Copy DisableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Disable in the Fetch domain.
func (a *DisableArgs) MarshalJSON() ([]byte, error) {
	type Copy DisableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// DisableReply represents the return values for Disable in the Fetch domain.
type DisableReply struct {
}

// DisableReply returns whether or not the FrameID matches the reply value for Disable in the Fetch domain.
func (a *DisableReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: DisableReply %s", err)
		return false, err
	}
	return true, nil
}

// DisableReply returns the FrameID value for Disable in the Fetch domain.
func (a *DisableReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for Disable in the Fetch domain.
func (a *DisableReply) UnmarshalJSON(b []byte) error {
	type Copy DisableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableReply(*c)
	return nil
}

// EnableArgs represents the arguments for Enable in the Fetch domain.
type EnableArgs struct {
	Patterns           *[]RequestPattern `json:"patterns,omitempty"`           // If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
	HandleAuthRequests bool              `json:"handleAuthRequests,omitempty"` // If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
}

// Unmarshal the byte array into a return value for Enable in the Fetch domain.
func (a *EnableArgs) UnmarshalJSON(b []byte) error {
	type Copy EnableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Enable in the Fetch domain.
func (a *EnableArgs) MarshalJSON() ([]byte, error) {
	type Copy EnableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EnableReply represents the return values for Enable in the Fetch domain.
type EnableReply struct {
}

// EnableReply returns whether or not the FrameID matches the reply value for Enable in the Fetch domain.
func (a *EnableReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: EnableReply %s", err)
		return false, err
	}
	return true, nil
}

// EnableReply returns the FrameID value for Enable in the Fetch domain.
func (a *EnableReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for Enable in the Fetch domain.
func (a *EnableReply) UnmarshalJSON(b []byte) error {
	type Copy EnableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableReply(*c)
	return nil
}

// FailRequestArgs represents the arguments for FailRequest in the Fetch domain.
type FailRequestArgs struct {
	RequestID   RequestID           `json:"requestId"`   // An id the client received in requestPaused event.
	ErrorReason network.ErrorReason `json:"errorReason"` // Causes the request to fail with the given reason.
}

// Unmarshal the byte array into a return value for FailRequest in the Fetch domain.
func (a *FailRequestArgs) UnmarshalJSON(b []byte) error {
	type Copy FailRequestArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = FailRequestArgs(*c)
	return nil
}

// Marshall the byte array into a return value for FailRequest in the Fetch domain.
func (a *FailRequestArgs) MarshalJSON() ([]byte, error) {
	type Copy FailRequestArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// FailRequestReply represents the return values for FailRequest in the Fetch domain.
type FailRequestReply struct {
}

// FailRequestReply returns whether or not the FrameID matches the reply value for FailRequest in the Fetch domain.
func (a *FailRequestReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: FailRequestReply %s", err)
		return false, err
	}
	return true, nil
}

// FailRequestReply returns the FrameID value for FailRequest in the Fetch domain.
func (a *FailRequestReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for FailRequest in the Fetch domain.
func (a *FailRequestReply) UnmarshalJSON(b []byte) error {
	type Copy FailRequestReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = FailRequestReply(*c)
	return nil
}

// FulfillRequestArgs represents the arguments for FulfillRequest in the Fetch domain.
type FulfillRequestArgs struct {
	RequestID             RequestID      `json:"requestId"`                       // An id the client received in requestPaused event.
	ResponseCode          int            `json:"responseCode"`                    // An HTTP response code.
	ResponseHeaders       *[]HeaderEntry `json:"responseHeaders,omitempty"`       // Response headers.
	BinaryResponseHeaders string         `json:"binaryResponseHeaders,omitempty"` // Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text.
	Body                  string         `json:"body,omitempty"`                  // A response body.
	ResponsePhrase        string         `json:"responsePhrase,omitempty"`        // A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
}

// Unmarshal the byte array into a return value for FulfillRequest in the Fetch domain.
func (a *FulfillRequestArgs) UnmarshalJSON(b []byte) error {
	type Copy FulfillRequestArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = FulfillRequestArgs(*c)
	return nil
}

// Marshall the byte array into a return value for FulfillRequest in the Fetch domain.
func (a *FulfillRequestArgs) MarshalJSON() ([]byte, error) {
	type Copy FulfillRequestArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// FulfillRequestReply represents the return values for FulfillRequest in the Fetch domain.
type FulfillRequestReply struct {
}

// FulfillRequestReply returns whether or not the FrameID matches the reply value for FulfillRequest in the Fetch domain.
func (a *FulfillRequestReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: FulfillRequestReply %s", err)
		return false, err
	}
	return true, nil
}

// FulfillRequestReply returns the FrameID value for FulfillRequest in the Fetch domain.
func (a *FulfillRequestReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for FulfillRequest in the Fetch domain.
func (a *FulfillRequestReply) UnmarshalJSON(b []byte) error {
	type Copy FulfillRequestReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = FulfillRequestReply(*c)
	return nil
}

// ContinueRequestArgs represents the arguments for ContinueRequest in the Fetch domain.
type ContinueRequestArgs struct {
	RequestID RequestID      `json:"requestId"`          // An id the client received in requestPaused event.
	URL       string         `json:"url,omitempty"`      // If set, the request url will be modified in a way that's not observable by page.
	Method    string         `json:"method,omitempty"`   // If set, the request method is overridden.
	PostData  string         `json:"postData,omitempty"` // If set, overrides the post data in the request.
	Headers   *[]HeaderEntry `json:"headers,omitempty"`  // If set, overrides the request headers.
}

// Unmarshal the byte array into a return value for ContinueRequest in the Fetch domain.
func (a *ContinueRequestArgs) UnmarshalJSON(b []byte) error {
	type Copy ContinueRequestArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueRequestArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ContinueRequest in the Fetch domain.
func (a *ContinueRequestArgs) MarshalJSON() ([]byte, error) {
	type Copy ContinueRequestArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ContinueRequestReply represents the return values for ContinueRequest in the Fetch domain.
type ContinueRequestReply struct {
}

// ContinueRequestReply returns whether or not the FrameID matches the reply value for ContinueRequest in the Fetch domain.
func (a *ContinueRequestReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: ContinueRequestReply %s", err)
		return false, err
	}
	return true, nil
}

// ContinueRequestReply returns the FrameID value for ContinueRequest in the Fetch domain.
func (a *ContinueRequestReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for ContinueRequest in the Fetch domain.
func (a *ContinueRequestReply) UnmarshalJSON(b []byte) error {
	type Copy ContinueRequestReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueRequestReply(*c)
	return nil
}

// ContinueWithAuthArgs represents the arguments for ContinueWithAuth in the Fetch domain.
type ContinueWithAuthArgs struct {
	RequestID             RequestID             `json:"requestId"`             // An id the client received in authRequired event.
	AuthChallengeResponse AuthChallengeResponse `json:"authChallengeResponse"` // Response to with an authChallenge.
}

// Unmarshal the byte array into a return value for ContinueWithAuth in the Fetch domain.
func (a *ContinueWithAuthArgs) UnmarshalJSON(b []byte) error {
	type Copy ContinueWithAuthArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueWithAuthArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ContinueWithAuth in the Fetch domain.
func (a *ContinueWithAuthArgs) MarshalJSON() ([]byte, error) {
	type Copy ContinueWithAuthArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ContinueWithAuthReply represents the return values for ContinueWithAuth in the Fetch domain.
type ContinueWithAuthReply struct {
}

// ContinueWithAuthReply returns whether or not the FrameID matches the reply value for ContinueWithAuth in the Fetch domain.
func (a *ContinueWithAuthReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: ContinueWithAuthReply %s", err)
		return false, err
	}
	return true, nil
}

// ContinueWithAuthReply returns the FrameID value for ContinueWithAuth in the Fetch domain.
func (a *ContinueWithAuthReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for ContinueWithAuth in the Fetch domain.
func (a *ContinueWithAuthReply) UnmarshalJSON(b []byte) error {
	type Copy ContinueWithAuthReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueWithAuthReply(*c)
	return nil
}

// GetResponseBodyArgs represents the arguments for GetResponseBody in the Fetch domain.
type GetResponseBodyArgs struct {
	RequestID RequestID `json:"requestId"` // Identifier for the intercepted request to get body for.
}

// Unmarshal the byte array into a return value for GetResponseBody in the Fetch domain.
func (a *GetResponseBodyArgs) UnmarshalJSON(b []byte) error {
	type Copy GetResponseBodyArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetResponseBodyArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetResponseBody in the Fetch domain.
func (a *GetResponseBodyArgs) MarshalJSON() ([]byte, error) {
	type Copy GetResponseBodyArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetResponseBodyReply represents the return values for GetResponseBody in the Fetch domain.
type GetResponseBodyReply struct {
	Body          string `json:"body"`          // Response body.
	Base64Encoded bool   `json:"base64Encoded"` // True, if content was sent as base64.
}

// GetResponseBodyReply returns whether or not the FrameID matches the reply value for GetResponseBody in the Fetch domain.
func (a *GetResponseBodyReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: GetResponseBodyReply %s", err)
		return false, err
	}
	return true, nil
}

// GetResponseBodyReply returns the FrameID value for GetResponseBody in the Fetch domain.
func (a *GetResponseBodyReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for GetResponseBody in the Fetch domain.
func (a *GetResponseBodyReply) UnmarshalJSON(b []byte) error {
	type Copy GetResponseBodyReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetResponseBodyReply(*c)
	return nil
}

// TakeResponseBodyAsStreamArgs represents the arguments for TakeResponseBodyAsStream in the Fetch domain.
type TakeResponseBodyAsStreamArgs struct {
	RequestID RequestID `json:"requestId"` // No description.
}

// Unmarshal the byte array into a return value for TakeResponseBodyAsStream in the Fetch domain.
func (a *TakeResponseBodyAsStreamArgs) UnmarshalJSON(b []byte) error {
	type Copy TakeResponseBodyAsStreamArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = TakeResponseBodyAsStreamArgs(*c)
	return nil
}

// Marshall the byte array into a return value for TakeResponseBodyAsStream in the Fetch domain.
func (a *TakeResponseBodyAsStreamArgs) MarshalJSON() ([]byte, error) {
	type Copy TakeResponseBodyAsStreamArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// TakeResponseBodyAsStreamReply represents the return values for TakeResponseBodyAsStream in the Fetch domain.
type TakeResponseBodyAsStreamReply struct {
	Stream io.StreamHandle `json:"stream"` // No description.
}

// TakeResponseBodyAsStreamReply returns whether or not the FrameID matches the reply value for TakeResponseBodyAsStream in the Fetch domain.
func (a *TakeResponseBodyAsStreamReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: TakeResponseBodyAsStreamReply %s", err)
		return false, err
	}
	return true, nil
}

// TakeResponseBodyAsStreamReply returns the FrameID value for TakeResponseBodyAsStream in the Fetch domain.
func (a *TakeResponseBodyAsStreamReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for TakeResponseBodyAsStream in the Fetch domain.
func (a *TakeResponseBodyAsStreamReply) UnmarshalJSON(b []byte) error {
	type Copy TakeResponseBodyAsStreamReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = TakeResponseBodyAsStreamReply(*c)
	return nil
}
