// Code generated by cdpgen. DO NOT EDIT.

package systeminfo

import (
	"encoding/json"
	"log"
)

const (
	CommandSystemInfoGetInfo = "SystemInfo.getInfo"
)

// GetInfoArgs represents the arguments for GetInfo in the SystemInfo domain.
type GetInfoArgs struct {
}

// Unmarshal the byte array into a return value for GetInfo in the SystemInfo domain.
func (a *GetInfoArgs) UnmarshalJSON(b []byte) error {
	type Copy GetInfoArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetInfoArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetInfo in the SystemInfo domain.
func (a *GetInfoArgs) MarshalJSON() ([]byte, error) {
	type Copy GetInfoArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetInfoReply represents the return values for GetInfo in the SystemInfo domain.
type GetInfoReply struct {
	GPU          GPUInfo `json:"gpu"`          // Information about the GPUs on the system.
	ModelName    string  `json:"modelName"`    // A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported.
	ModelVersion string  `json:"modelVersion"` // A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported.
	CommandLine  string  `json:"commandLine"`  // The command line string used to launch the browser. Will be the empty string if not supported.
}

// GetInfoReply returns whether or not the FrameID matches the reply value for GetInfo in the SystemInfo domain.
func (a *GetInfoReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetInfoReply %s", err)
	}
	return true
}

// GetInfoReply returns the FrameID value for GetInfo in the SystemInfo domain.
func (a *GetInfoReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for GetInfo in the SystemInfo domain.
func (a *GetInfoReply) UnmarshalJSON(b []byte) error {
	type Copy GetInfoReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetInfoReply(*c)
	return nil
}
