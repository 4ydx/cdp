// Code generated by cdpgen. DO NOT EDIT.

package network

import (
	"encoding/json"
	"log"

	"github.com/4ydx/cdp/protocol"
)

const (
	EventNetworkDataReceived                       = "Network.dataReceived"
	EventNetworkEventSourceMessageReceived         = "Network.eventSourceMessageReceived"
	EventNetworkLoadingFailed                      = "Network.loadingFailed"
	EventNetworkLoadingFinished                    = "Network.loadingFinished"
	EventNetworkRequestIntercepted                 = "Network.requestIntercepted"
	EventNetworkRequestServedFromCache             = "Network.requestServedFromCache"
	EventNetworkRequestWillBeSent                  = "Network.requestWillBeSent"
	EventNetworkResourceChangedPriority            = "Network.resourceChangedPriority"
	EventNetworkSignedExchangeReceived             = "Network.signedExchangeReceived"
	EventNetworkResponseReceived                   = "Network.responseReceived"
	EventNetworkWebSocketClosed                    = "Network.webSocketClosed"
	EventNetworkWebSocketCreated                   = "Network.webSocketCreated"
	EventNetworkWebSocketFrameError                = "Network.webSocketFrameError"
	EventNetworkWebSocketFrameReceived             = "Network.webSocketFrameReceived"
	EventNetworkWebSocketFrameSent                 = "Network.webSocketFrameSent"
	EventNetworkWebSocketHandshakeResponseReceived = "Network.webSocketHandshakeResponseReceived"
	EventNetworkWebSocketWillSendHandshakeRequest  = "Network.webSocketWillSendHandshakeRequest"
)

type Unmarshaler func() json.Unmarshaler

var EventConstants = map[string]Unmarshaler{
	EventNetworkDataReceived:                       func() json.Unmarshaler { return &DataReceivedReply{} },
	EventNetworkEventSourceMessageReceived:         func() json.Unmarshaler { return &EventSourceMessageReceivedReply{} },
	EventNetworkLoadingFailed:                      func() json.Unmarshaler { return &LoadingFailedReply{} },
	EventNetworkLoadingFinished:                    func() json.Unmarshaler { return &LoadingFinishedReply{} },
	EventNetworkRequestIntercepted:                 func() json.Unmarshaler { return &RequestInterceptedReply{} },
	EventNetworkRequestServedFromCache:             func() json.Unmarshaler { return &RequestServedFromCacheReply{} },
	EventNetworkRequestWillBeSent:                  func() json.Unmarshaler { return &RequestWillBeSentReply{} },
	EventNetworkResourceChangedPriority:            func() json.Unmarshaler { return &ResourceChangedPriorityReply{} },
	EventNetworkSignedExchangeReceived:             func() json.Unmarshaler { return &SignedExchangeReceivedReply{} },
	EventNetworkResponseReceived:                   func() json.Unmarshaler { return &ResponseReceivedReply{} },
	EventNetworkWebSocketClosed:                    func() json.Unmarshaler { return &WebSocketClosedReply{} },
	EventNetworkWebSocketCreated:                   func() json.Unmarshaler { return &WebSocketCreatedReply{} },
	EventNetworkWebSocketFrameError:                func() json.Unmarshaler { return &WebSocketFrameErrorReply{} },
	EventNetworkWebSocketFrameReceived:             func() json.Unmarshaler { return &WebSocketFrameReceivedReply{} },
	EventNetworkWebSocketFrameSent:                 func() json.Unmarshaler { return &WebSocketFrameSentReply{} },
	EventNetworkWebSocketHandshakeResponseReceived: func() json.Unmarshaler { return &WebSocketHandshakeResponseReceivedReply{} },
	EventNetworkWebSocketWillSendHandshakeRequest:  func() json.Unmarshaler { return &WebSocketWillSendHandshakeRequestReply{} },
}

func GetEventReply(event string) (json.Unmarshaler, bool) {
	e, ok := EventConstants[event]
	if ok {
		return e(), ok
	}
	return nil, ok
}

// DataReceivedReply is the reply for DataReceived events.
type DataReceivedReply struct {
	RequestID         RequestID     `json:"requestId"`         // Request identifier.
	Timestamp         MonotonicTime `json:"timestamp"`         // Timestamp.
	DataLength        int           `json:"dataLength"`        // Data chunk length.
	EncodedDataLength int           `json:"encodedDataLength"` // Actual bytes received (might be less than dataLength for compressed encodings).
}

// Unmarshal the byte array into a return value for DataReceived in the Network domain.
func (a *DataReceivedReply) UnmarshalJSON(b []byte) error {
	type Copy DataReceivedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DataReceivedReply(*c)
	return nil
}

// DataReceivedReply returns whether or not the FrameID matches the reply value for DataReceived in the Network domain.
func (a *DataReceivedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: DataReceivedReply %s", err)
	}
	return true
}

// DataReceivedReply returns the FrameID for DataReceived in the Network domain.
func (a *DataReceivedReply) GetFrameID() string {
	return ""
}

// EventSourceMessageReceivedReply is the reply for EventSourceMessageReceived events.
type EventSourceMessageReceivedReply struct {
	RequestID RequestID     `json:"requestId"` // Request identifier.
	Timestamp MonotonicTime `json:"timestamp"` // Timestamp.
	EventName string        `json:"eventName"` // Message type.
	EventID   string        `json:"eventId"`   // Message identifier.
	Data      string        `json:"data"`      // Message content.
}

// Unmarshal the byte array into a return value for EventSourceMessageReceived in the Network domain.
func (a *EventSourceMessageReceivedReply) UnmarshalJSON(b []byte) error {
	type Copy EventSourceMessageReceivedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EventSourceMessageReceivedReply(*c)
	return nil
}

// EventSourceMessageReceivedReply returns whether or not the FrameID matches the reply value for EventSourceMessageReceived in the Network domain.
func (a *EventSourceMessageReceivedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: EventSourceMessageReceivedReply %s", err)
	}
	return true
}

// EventSourceMessageReceivedReply returns the FrameID for EventSourceMessageReceived in the Network domain.
func (a *EventSourceMessageReceivedReply) GetFrameID() string {
	return ""
}

// LoadingFailedReply is the reply for LoadingFailed events.
type LoadingFailedReply struct {
	RequestID     RequestID           `json:"requestId"`               // Request identifier.
	Timestamp     MonotonicTime       `json:"timestamp"`               // Timestamp.
	Type          shared.ResourceType `json:"type"`                    // Resource type.
	ErrorText     string              `json:"errorText"`               // User friendly error message.
	Canceled      bool                `json:"canceled,omitempty"`      // True if loading was canceled.
	BlockedReason BlockedReason       `json:"blockedReason,omitempty"` // The reason why loading was blocked, if any.
}

// Unmarshal the byte array into a return value for LoadingFailed in the Network domain.
func (a *LoadingFailedReply) UnmarshalJSON(b []byte) error {
	type Copy LoadingFailedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = LoadingFailedReply(*c)
	return nil
}

// LoadingFailedReply returns whether or not the FrameID matches the reply value for LoadingFailed in the Network domain.
func (a *LoadingFailedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: LoadingFailedReply %s", err)
	}
	return true
}

// LoadingFailedReply returns the FrameID for LoadingFailed in the Network domain.
func (a *LoadingFailedReply) GetFrameID() string {
	return ""
}

// LoadingFinishedReply is the reply for LoadingFinished events.
type LoadingFinishedReply struct {
	RequestID                RequestID     `json:"requestId"`                          // Request identifier.
	Timestamp                MonotonicTime `json:"timestamp"`                          // Timestamp.
	EncodedDataLength        float64       `json:"encodedDataLength"`                  // Total number of bytes received for this request.
	ShouldReportCorbBlocking bool          `json:"shouldReportCorbBlocking,omitempty"` // Set when 1) response was blocked by Cross-Origin Read Blocking and also 2) this needs to be reported to the DevTools console.
}

// Unmarshal the byte array into a return value for LoadingFinished in the Network domain.
func (a *LoadingFinishedReply) UnmarshalJSON(b []byte) error {
	type Copy LoadingFinishedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = LoadingFinishedReply(*c)
	return nil
}

// LoadingFinishedReply returns whether or not the FrameID matches the reply value for LoadingFinished in the Network domain.
func (a *LoadingFinishedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: LoadingFinishedReply %s", err)
	}
	return true
}

// LoadingFinishedReply returns the FrameID for LoadingFinished in the Network domain.
func (a *LoadingFinishedReply) GetFrameID() string {
	return ""
}

// RequestInterceptedReply is the reply for RequestIntercepted events.
type RequestInterceptedReply struct {
	InterceptionID      InterceptionID      `json:"interceptionId"`                // Each request the page makes will have a unique id, however if any redirects are encountered while processing that fetch, they will be reported with the same id as the original fetch. Likewise if HTTP authentication is needed then the same fetch id will be used.
	Request             Request             `json:"request"`                       // No description.
	FrameID             shared.FrameID      `json:"frameId"`                       // The id of the frame that initiated the request.
	ResourceType        shared.ResourceType `json:"resourceType"`                  // How the requested resource will be used.
	IsNavigationRequest bool                `json:"isNavigationRequest"`           // Whether this is a navigation request, which can abort the navigation completely.
	IsDownload          bool                `json:"isDownload,omitempty"`          // Set if the request is a navigation that will result in a download. Only present after response is received from the server (i.e. HeadersReceived stage).
	RedirectURL         string              `json:"redirectUrl,omitempty"`         // Redirect location, only sent if a redirect was intercepted.
	AuthChallenge       AuthChallenge       `json:"authChallenge,omitempty"`       // Details of the Authorization Challenge encountered. If this is set then continueInterceptedRequest must contain an authChallengeResponse.
	ResponseErrorReason ErrorReason         `json:"responseErrorReason,omitempty"` // Response error if intercepted at response stage or if redirect occurred while intercepting request.
	ResponseStatusCode  int                 `json:"responseStatusCode,omitempty"`  // Response code if intercepted at response stage or if redirect occurred while intercepting request or auth retry occurred.
	ResponseHeaders     Headers             `json:"responseHeaders,omitempty"`     // Response headers if intercepted at the response stage or if redirect occurred while intercepting request or auth retry occurred.
}

// Unmarshal the byte array into a return value for RequestIntercepted in the Network domain.
func (a *RequestInterceptedReply) UnmarshalJSON(b []byte) error {
	type Copy RequestInterceptedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RequestInterceptedReply(*c)
	return nil
}

// RequestInterceptedReply returns whether or not the FrameID matches the reply value for RequestIntercepted in the Network domain.
func (a *RequestInterceptedReply) MatchFrameID(frameID string, m []byte) bool {
	v := &RequestInterceptedReply{}
	err := v.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RequestInterceptedReply %s", err)
	}
	if v.FrameID != shared.FrameID(frameID) {
		return false
	}
	*a = *v
	return true
}

// RequestInterceptedReply returns the FrameID for RequestIntercepted in the Network domain.
func (a *RequestInterceptedReply) GetFrameID() string {
	return string(a.FrameID)
}

// RequestServedFromCacheReply is the reply for RequestServedFromCache events.
type RequestServedFromCacheReply struct {
	RequestID RequestID `json:"requestId"` // Request identifier.
}

// Unmarshal the byte array into a return value for RequestServedFromCache in the Network domain.
func (a *RequestServedFromCacheReply) UnmarshalJSON(b []byte) error {
	type Copy RequestServedFromCacheReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RequestServedFromCacheReply(*c)
	return nil
}

// RequestServedFromCacheReply returns whether or not the FrameID matches the reply value for RequestServedFromCache in the Network domain.
func (a *RequestServedFromCacheReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RequestServedFromCacheReply %s", err)
	}
	return true
}

// RequestServedFromCacheReply returns the FrameID for RequestServedFromCache in the Network domain.
func (a *RequestServedFromCacheReply) GetFrameID() string {
	return ""
}

// RequestWillBeSentReply is the reply for RequestWillBeSent events.
type RequestWillBeSentReply struct {
	RequestID        RequestID           `json:"requestId"`                  // Request identifier.
	LoaderID         LoaderID            `json:"loaderId"`                   // Loader identifier. Empty string if the request is fetched from worker.
	DocumentURL      string              `json:"documentURL"`                // URL of the document this request is loaded for.
	Request          Request             `json:"request"`                    // Request data.
	Timestamp        MonotonicTime       `json:"timestamp"`                  // Timestamp.
	WallTime         TimeSinceEpoch      `json:"wallTime"`                   // Timestamp.
	Initiator        Initiator           `json:"initiator"`                  // Request initiator.
	RedirectResponse Response            `json:"redirectResponse,omitempty"` // Redirect response data.
	Type             shared.ResourceType `json:"type,omitempty"`             // Type of this resource.
	FrameID          shared.FrameID      `json:"frameId,omitempty"`          // Frame identifier.
	HasUserGesture   bool                `json:"hasUserGesture,omitempty"`   // Whether the request is initiated by a user gesture. Defaults to false.
}

// Unmarshal the byte array into a return value for RequestWillBeSent in the Network domain.
func (a *RequestWillBeSentReply) UnmarshalJSON(b []byte) error {
	type Copy RequestWillBeSentReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RequestWillBeSentReply(*c)
	return nil
}

// RequestWillBeSentReply returns whether or not the FrameID matches the reply value for RequestWillBeSent in the Network domain.
func (a *RequestWillBeSentReply) MatchFrameID(frameID string, m []byte) bool {
	v := &RequestWillBeSentReply{}
	err := v.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RequestWillBeSentReply %s", err)
	}
	if v.FrameID != shared.FrameID(frameID) {
		return false
	}
	*a = *v
	return true
}

// RequestWillBeSentReply returns the FrameID for RequestWillBeSent in the Network domain.
func (a *RequestWillBeSentReply) GetFrameID() string {
	return string(a.FrameID)
}

// ResourceChangedPriorityReply is the reply for ResourceChangedPriority events.
type ResourceChangedPriorityReply struct {
	RequestID   RequestID        `json:"requestId"`   // Request identifier.
	NewPriority ResourcePriority `json:"newPriority"` // New priority
	Timestamp   MonotonicTime    `json:"timestamp"`   // Timestamp.
}

// Unmarshal the byte array into a return value for ResourceChangedPriority in the Network domain.
func (a *ResourceChangedPriorityReply) UnmarshalJSON(b []byte) error {
	type Copy ResourceChangedPriorityReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ResourceChangedPriorityReply(*c)
	return nil
}

// ResourceChangedPriorityReply returns whether or not the FrameID matches the reply value for ResourceChangedPriority in the Network domain.
func (a *ResourceChangedPriorityReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ResourceChangedPriorityReply %s", err)
	}
	return true
}

// ResourceChangedPriorityReply returns the FrameID for ResourceChangedPriority in the Network domain.
func (a *ResourceChangedPriorityReply) GetFrameID() string {
	return ""
}

// SignedExchangeReceivedReply is the reply for SignedExchangeReceived events.
type SignedExchangeReceivedReply struct {
	RequestID RequestID          `json:"requestId"` // Request identifier.
	Info      SignedExchangeInfo `json:"info"`      // Information about the signed exchange response.
}

// Unmarshal the byte array into a return value for SignedExchangeReceived in the Network domain.
func (a *SignedExchangeReceivedReply) UnmarshalJSON(b []byte) error {
	type Copy SignedExchangeReceivedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SignedExchangeReceivedReply(*c)
	return nil
}

// SignedExchangeReceivedReply returns whether or not the FrameID matches the reply value for SignedExchangeReceived in the Network domain.
func (a *SignedExchangeReceivedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SignedExchangeReceivedReply %s", err)
	}
	return true
}

// SignedExchangeReceivedReply returns the FrameID for SignedExchangeReceived in the Network domain.
func (a *SignedExchangeReceivedReply) GetFrameID() string {
	return ""
}

// ResponseReceivedReply is the reply for ResponseReceived events.
type ResponseReceivedReply struct {
	RequestID RequestID           `json:"requestId"`         // Request identifier.
	LoaderID  LoaderID            `json:"loaderId"`          // Loader identifier. Empty string if the request is fetched from worker.
	Timestamp MonotonicTime       `json:"timestamp"`         // Timestamp.
	Type      shared.ResourceType `json:"type"`              // Resource type.
	Response  Response            `json:"response"`          // Response data.
	FrameID   shared.FrameID      `json:"frameId,omitempty"` // Frame identifier.
}

// Unmarshal the byte array into a return value for ResponseReceived in the Network domain.
func (a *ResponseReceivedReply) UnmarshalJSON(b []byte) error {
	type Copy ResponseReceivedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ResponseReceivedReply(*c)
	return nil
}

// ResponseReceivedReply returns whether or not the FrameID matches the reply value for ResponseReceived in the Network domain.
func (a *ResponseReceivedReply) MatchFrameID(frameID string, m []byte) bool {
	v := &ResponseReceivedReply{}
	err := v.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ResponseReceivedReply %s", err)
	}
	if v.FrameID != shared.FrameID(frameID) {
		return false
	}
	*a = *v
	return true
}

// ResponseReceivedReply returns the FrameID for ResponseReceived in the Network domain.
func (a *ResponseReceivedReply) GetFrameID() string {
	return string(a.FrameID)
}

// WebSocketClosedReply is the reply for WebSocketClosed events.
type WebSocketClosedReply struct {
	RequestID RequestID     `json:"requestId"` // Request identifier.
	Timestamp MonotonicTime `json:"timestamp"` // Timestamp.
}

// Unmarshal the byte array into a return value for WebSocketClosed in the Network domain.
func (a *WebSocketClosedReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketClosedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketClosedReply(*c)
	return nil
}

// WebSocketClosedReply returns whether or not the FrameID matches the reply value for WebSocketClosed in the Network domain.
func (a *WebSocketClosedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketClosedReply %s", err)
	}
	return true
}

// WebSocketClosedReply returns the FrameID for WebSocketClosed in the Network domain.
func (a *WebSocketClosedReply) GetFrameID() string {
	return ""
}

// WebSocketCreatedReply is the reply for WebSocketCreated events.
type WebSocketCreatedReply struct {
	RequestID RequestID `json:"requestId"`           // Request identifier.
	URL       string    `json:"url"`                 // WebSocket request URL.
	Initiator Initiator `json:"initiator,omitempty"` // Request initiator.
}

// Unmarshal the byte array into a return value for WebSocketCreated in the Network domain.
func (a *WebSocketCreatedReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketCreatedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketCreatedReply(*c)
	return nil
}

// WebSocketCreatedReply returns whether or not the FrameID matches the reply value for WebSocketCreated in the Network domain.
func (a *WebSocketCreatedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketCreatedReply %s", err)
	}
	return true
}

// WebSocketCreatedReply returns the FrameID for WebSocketCreated in the Network domain.
func (a *WebSocketCreatedReply) GetFrameID() string {
	return ""
}

// WebSocketFrameErrorReply is the reply for WebSocketFrameError events.
type WebSocketFrameErrorReply struct {
	RequestID    RequestID     `json:"requestId"`    // Request identifier.
	Timestamp    MonotonicTime `json:"timestamp"`    // Timestamp.
	ErrorMessage string        `json:"errorMessage"` // WebSocket frame error message.
}

// Unmarshal the byte array into a return value for WebSocketFrameError in the Network domain.
func (a *WebSocketFrameErrorReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketFrameErrorReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketFrameErrorReply(*c)
	return nil
}

// WebSocketFrameErrorReply returns whether or not the FrameID matches the reply value for WebSocketFrameError in the Network domain.
func (a *WebSocketFrameErrorReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketFrameErrorReply %s", err)
	}
	return true
}

// WebSocketFrameErrorReply returns the FrameID for WebSocketFrameError in the Network domain.
func (a *WebSocketFrameErrorReply) GetFrameID() string {
	return ""
}

// WebSocketFrameReceivedReply is the reply for WebSocketFrameReceived events.
type WebSocketFrameReceivedReply struct {
	RequestID RequestID      `json:"requestId"` // Request identifier.
	Timestamp MonotonicTime  `json:"timestamp"` // Timestamp.
	Response  WebSocketFrame `json:"response"`  // WebSocket response data.
}

// Unmarshal the byte array into a return value for WebSocketFrameReceived in the Network domain.
func (a *WebSocketFrameReceivedReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketFrameReceivedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketFrameReceivedReply(*c)
	return nil
}

// WebSocketFrameReceivedReply returns whether or not the FrameID matches the reply value for WebSocketFrameReceived in the Network domain.
func (a *WebSocketFrameReceivedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketFrameReceivedReply %s", err)
	}
	return true
}

// WebSocketFrameReceivedReply returns the FrameID for WebSocketFrameReceived in the Network domain.
func (a *WebSocketFrameReceivedReply) GetFrameID() string {
	return ""
}

// WebSocketFrameSentReply is the reply for WebSocketFrameSent events.
type WebSocketFrameSentReply struct {
	RequestID RequestID      `json:"requestId"` // Request identifier.
	Timestamp MonotonicTime  `json:"timestamp"` // Timestamp.
	Response  WebSocketFrame `json:"response"`  // WebSocket response data.
}

// Unmarshal the byte array into a return value for WebSocketFrameSent in the Network domain.
func (a *WebSocketFrameSentReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketFrameSentReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketFrameSentReply(*c)
	return nil
}

// WebSocketFrameSentReply returns whether or not the FrameID matches the reply value for WebSocketFrameSent in the Network domain.
func (a *WebSocketFrameSentReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketFrameSentReply %s", err)
	}
	return true
}

// WebSocketFrameSentReply returns the FrameID for WebSocketFrameSent in the Network domain.
func (a *WebSocketFrameSentReply) GetFrameID() string {
	return ""
}

// WebSocketHandshakeResponseReceivedReply is the reply for WebSocketHandshakeResponseReceived events.
type WebSocketHandshakeResponseReceivedReply struct {
	RequestID RequestID         `json:"requestId"` // Request identifier.
	Timestamp MonotonicTime     `json:"timestamp"` // Timestamp.
	Response  WebSocketResponse `json:"response"`  // WebSocket response data.
}

// Unmarshal the byte array into a return value for WebSocketHandshakeResponseReceived in the Network domain.
func (a *WebSocketHandshakeResponseReceivedReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketHandshakeResponseReceivedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketHandshakeResponseReceivedReply(*c)
	return nil
}

// WebSocketHandshakeResponseReceivedReply returns whether or not the FrameID matches the reply value for WebSocketHandshakeResponseReceived in the Network domain.
func (a *WebSocketHandshakeResponseReceivedReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketHandshakeResponseReceivedReply %s", err)
	}
	return true
}

// WebSocketHandshakeResponseReceivedReply returns the FrameID for WebSocketHandshakeResponseReceived in the Network domain.
func (a *WebSocketHandshakeResponseReceivedReply) GetFrameID() string {
	return ""
}

// WebSocketWillSendHandshakeRequestReply is the reply for WebSocketWillSendHandshakeRequest events.
type WebSocketWillSendHandshakeRequestReply struct {
	RequestID RequestID        `json:"requestId"` // Request identifier.
	Timestamp MonotonicTime    `json:"timestamp"` // Timestamp.
	WallTime  TimeSinceEpoch   `json:"wallTime"`  // UTC Timestamp.
	Request   WebSocketRequest `json:"request"`   // WebSocket request data.
}

// Unmarshal the byte array into a return value for WebSocketWillSendHandshakeRequest in the Network domain.
func (a *WebSocketWillSendHandshakeRequestReply) UnmarshalJSON(b []byte) error {
	type Copy WebSocketWillSendHandshakeRequestReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = WebSocketWillSendHandshakeRequestReply(*c)
	return nil
}

// WebSocketWillSendHandshakeRequestReply returns whether or not the FrameID matches the reply value for WebSocketWillSendHandshakeRequest in the Network domain.
func (a *WebSocketWillSendHandshakeRequestReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: WebSocketWillSendHandshakeRequestReply %s", err)
	}
	return true
}

// WebSocketWillSendHandshakeRequestReply returns the FrameID for WebSocketWillSendHandshakeRequest in the Network domain.
func (a *WebSocketWillSendHandshakeRequestReply) GetFrameID() string {
	return ""
}
