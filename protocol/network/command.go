// Code generated by cdpgen. DO NOT EDIT.

package network

import (
	"encoding/json"
	"log"

	"github.com/4ydx/cdp/protocol/debugger"
	"github.com/4ydx/cdp/protocol/io"
)

const (
	CommandNetworkCanClearBrowserCache                    = "Network.canClearBrowserCache"
	CommandNetworkCanClearBrowserCookies                  = "Network.canClearBrowserCookies"
	CommandNetworkCanEmulateNetworkConditions             = "Network.canEmulateNetworkConditions"
	CommandNetworkClearBrowserCache                       = "Network.clearBrowserCache"
	CommandNetworkClearBrowserCookies                     = "Network.clearBrowserCookies"
	CommandNetworkContinueInterceptedRequest              = "Network.continueInterceptedRequest"
	CommandNetworkDeleteCookies                           = "Network.deleteCookies"
	CommandNetworkDisable                                 = "Network.disable"
	CommandNetworkEmulateNetworkConditions                = "Network.emulateNetworkConditions"
	CommandNetworkEnable                                  = "Network.enable"
	CommandNetworkGetAllCookies                           = "Network.getAllCookies"
	CommandNetworkGetCertificate                          = "Network.getCertificate"
	CommandNetworkGetCookies                              = "Network.getCookies"
	CommandNetworkGetResponseBody                         = "Network.getResponseBody"
	CommandNetworkGetRequestPostData                      = "Network.getRequestPostData"
	CommandNetworkGetResponseBodyForInterception          = "Network.getResponseBodyForInterception"
	CommandNetworkTakeResponseBodyForInterceptionAsStream = "Network.takeResponseBodyForInterceptionAsStream"
	CommandNetworkReplayXHR                               = "Network.replayXHR"
	CommandNetworkSearchInResponseBody                    = "Network.searchInResponseBody"
	CommandNetworkSetBlockedURLs                          = "Network.setBlockedURLs"
	CommandNetworkSetBypassServiceWorker                  = "Network.setBypassServiceWorker"
	CommandNetworkSetCacheDisabled                        = "Network.setCacheDisabled"
	CommandNetworkSetCookie                               = "Network.setCookie"
	CommandNetworkSetCookies                              = "Network.setCookies"
	CommandNetworkSetDataSizeLimitsForTest                = "Network.setDataSizeLimitsForTest"
	CommandNetworkSetExtraHTTPHeaders                     = "Network.setExtraHTTPHeaders"
	CommandNetworkSetRequestInterception                  = "Network.setRequestInterception"
	CommandNetworkSetUserAgentOverride                    = "Network.setUserAgentOverride"
)

// CanClearBrowserCacheArgs represents the arguments for CanClearBrowserCache in the Network domain.
type CanClearBrowserCacheArgs struct {
}

// Unmarshal the byte array into a return value for CanClearBrowserCache in the Network domain.
func (a *CanClearBrowserCacheArgs) UnmarshalJSON(b []byte) error {
	type Copy CanClearBrowserCacheArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CanClearBrowserCacheArgs(*c)
	return nil
}

// Marshall the byte array into a return value for CanClearBrowserCache in the Network domain.
func (a *CanClearBrowserCacheArgs) MarshalJSON() ([]byte, error) {
	type Copy CanClearBrowserCacheArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// CanClearBrowserCacheReply represents the return values for CanClearBrowserCache in the Network domain.
type CanClearBrowserCacheReply struct {
	Result bool `json:"result"` // True if browser cache can be cleared.
}

// CanClearBrowserCacheReply returns whether or not the FrameID matches the reply value for CanClearBrowserCache in the Network domain.
func (a *CanClearBrowserCacheReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: CanClearBrowserCacheReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for CanClearBrowserCache in the Network domain.
func (a *CanClearBrowserCacheReply) UnmarshalJSON(b []byte) error {
	type Copy CanClearBrowserCacheReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CanClearBrowserCacheReply(*c)
	return nil
}

// CanClearBrowserCookiesArgs represents the arguments for CanClearBrowserCookies in the Network domain.
type CanClearBrowserCookiesArgs struct {
}

// Unmarshal the byte array into a return value for CanClearBrowserCookies in the Network domain.
func (a *CanClearBrowserCookiesArgs) UnmarshalJSON(b []byte) error {
	type Copy CanClearBrowserCookiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CanClearBrowserCookiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for CanClearBrowserCookies in the Network domain.
func (a *CanClearBrowserCookiesArgs) MarshalJSON() ([]byte, error) {
	type Copy CanClearBrowserCookiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// CanClearBrowserCookiesReply represents the return values for CanClearBrowserCookies in the Network domain.
type CanClearBrowserCookiesReply struct {
	Result bool `json:"result"` // True if browser cookies can be cleared.
}

// CanClearBrowserCookiesReply returns whether or not the FrameID matches the reply value for CanClearBrowserCookies in the Network domain.
func (a *CanClearBrowserCookiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: CanClearBrowserCookiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for CanClearBrowserCookies in the Network domain.
func (a *CanClearBrowserCookiesReply) UnmarshalJSON(b []byte) error {
	type Copy CanClearBrowserCookiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CanClearBrowserCookiesReply(*c)
	return nil
}

// CanEmulateNetworkConditionsArgs represents the arguments for CanEmulateNetworkConditions in the Network domain.
type CanEmulateNetworkConditionsArgs struct {
}

// Unmarshal the byte array into a return value for CanEmulateNetworkConditions in the Network domain.
func (a *CanEmulateNetworkConditionsArgs) UnmarshalJSON(b []byte) error {
	type Copy CanEmulateNetworkConditionsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CanEmulateNetworkConditionsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for CanEmulateNetworkConditions in the Network domain.
func (a *CanEmulateNetworkConditionsArgs) MarshalJSON() ([]byte, error) {
	type Copy CanEmulateNetworkConditionsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// CanEmulateNetworkConditionsReply represents the return values for CanEmulateNetworkConditions in the Network domain.
type CanEmulateNetworkConditionsReply struct {
	Result bool `json:"result"` // True if emulation of network conditions is supported.
}

// CanEmulateNetworkConditionsReply returns whether or not the FrameID matches the reply value for CanEmulateNetworkConditions in the Network domain.
func (a *CanEmulateNetworkConditionsReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: CanEmulateNetworkConditionsReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for CanEmulateNetworkConditions in the Network domain.
func (a *CanEmulateNetworkConditionsReply) UnmarshalJSON(b []byte) error {
	type Copy CanEmulateNetworkConditionsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CanEmulateNetworkConditionsReply(*c)
	return nil
}

// ClearBrowserCacheArgs represents the arguments for ClearBrowserCache in the Network domain.
type ClearBrowserCacheArgs struct {
}

// Unmarshal the byte array into a return value for ClearBrowserCache in the Network domain.
func (a *ClearBrowserCacheArgs) UnmarshalJSON(b []byte) error {
	type Copy ClearBrowserCacheArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ClearBrowserCacheArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ClearBrowserCache in the Network domain.
func (a *ClearBrowserCacheArgs) MarshalJSON() ([]byte, error) {
	type Copy ClearBrowserCacheArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ClearBrowserCacheReply represents the return values for ClearBrowserCache in the Network domain.
type ClearBrowserCacheReply struct {
}

// ClearBrowserCacheReply returns whether or not the FrameID matches the reply value for ClearBrowserCache in the Network domain.
func (a *ClearBrowserCacheReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ClearBrowserCacheReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for ClearBrowserCache in the Network domain.
func (a *ClearBrowserCacheReply) UnmarshalJSON(b []byte) error {
	type Copy ClearBrowserCacheReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ClearBrowserCacheReply(*c)
	return nil
}

// ClearBrowserCookiesArgs represents the arguments for ClearBrowserCookies in the Network domain.
type ClearBrowserCookiesArgs struct {
}

// Unmarshal the byte array into a return value for ClearBrowserCookies in the Network domain.
func (a *ClearBrowserCookiesArgs) UnmarshalJSON(b []byte) error {
	type Copy ClearBrowserCookiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ClearBrowserCookiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ClearBrowserCookies in the Network domain.
func (a *ClearBrowserCookiesArgs) MarshalJSON() ([]byte, error) {
	type Copy ClearBrowserCookiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ClearBrowserCookiesReply represents the return values for ClearBrowserCookies in the Network domain.
type ClearBrowserCookiesReply struct {
}

// ClearBrowserCookiesReply returns whether or not the FrameID matches the reply value for ClearBrowserCookies in the Network domain.
func (a *ClearBrowserCookiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ClearBrowserCookiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for ClearBrowserCookies in the Network domain.
func (a *ClearBrowserCookiesReply) UnmarshalJSON(b []byte) error {
	type Copy ClearBrowserCookiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ClearBrowserCookiesReply(*c)
	return nil
}

// ContinueInterceptedRequestArgs represents the arguments for ContinueInterceptedRequest in the Network domain.
type ContinueInterceptedRequestArgs struct {
	InterceptionID        InterceptionID        `json:"interceptionId"`                  // No description.
	ErrorReason           ErrorReason           `json:"errorReason,omitempty"`           // If set this causes the request to fail with the given reason. Passing `Aborted` for requests marked with `isNavigationRequest` also cancels the navigation. Must not be set in response to an authChallenge.
	RawResponse           string                `json:"rawResponse,omitempty"`           // If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge.
	URL                   string                `json:"url,omitempty"`                   // If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge.
	Method                string                `json:"method,omitempty"`                // If set this allows the request method to be overridden. Must not be set in response to an authChallenge.
	PostData              string                `json:"postData,omitempty"`              // If set this allows postData to be set. Must not be set in response to an authChallenge.
	Headers               Headers               `json:"headers,omitempty"`               // If set this allows the request headers to be changed. Must not be set in response to an authChallenge.
	AuthChallengeResponse AuthChallengeResponse `json:"authChallengeResponse,omitempty"` // Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
}

// Unmarshal the byte array into a return value for ContinueInterceptedRequest in the Network domain.
func (a *ContinueInterceptedRequestArgs) UnmarshalJSON(b []byte) error {
	type Copy ContinueInterceptedRequestArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueInterceptedRequestArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ContinueInterceptedRequest in the Network domain.
func (a *ContinueInterceptedRequestArgs) MarshalJSON() ([]byte, error) {
	type Copy ContinueInterceptedRequestArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ContinueInterceptedRequestReply represents the return values for ContinueInterceptedRequest in the Network domain.
type ContinueInterceptedRequestReply struct {
}

// ContinueInterceptedRequestReply returns whether or not the FrameID matches the reply value for ContinueInterceptedRequest in the Network domain.
func (a *ContinueInterceptedRequestReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ContinueInterceptedRequestReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for ContinueInterceptedRequest in the Network domain.
func (a *ContinueInterceptedRequestReply) UnmarshalJSON(b []byte) error {
	type Copy ContinueInterceptedRequestReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueInterceptedRequestReply(*c)
	return nil
}

// DeleteCookiesArgs represents the arguments for DeleteCookies in the Network domain.
type DeleteCookiesArgs struct {
	Name   string `json:"name"`             // Name of the cookies to remove.
	URL    string `json:"url,omitempty"`    // If specified, deletes all the cookies with the given name where domain and path match provided URL.
	Domain string `json:"domain,omitempty"` // If specified, deletes only cookies with the exact domain.
	Path   string `json:"path,omitempty"`   // If specified, deletes only cookies with the exact path.
}

// Unmarshal the byte array into a return value for DeleteCookies in the Network domain.
func (a *DeleteCookiesArgs) UnmarshalJSON(b []byte) error {
	type Copy DeleteCookiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DeleteCookiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for DeleteCookies in the Network domain.
func (a *DeleteCookiesArgs) MarshalJSON() ([]byte, error) {
	type Copy DeleteCookiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// DeleteCookiesReply represents the return values for DeleteCookies in the Network domain.
type DeleteCookiesReply struct {
}

// DeleteCookiesReply returns whether or not the FrameID matches the reply value for DeleteCookies in the Network domain.
func (a *DeleteCookiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: DeleteCookiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for DeleteCookies in the Network domain.
func (a *DeleteCookiesReply) UnmarshalJSON(b []byte) error {
	type Copy DeleteCookiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DeleteCookiesReply(*c)
	return nil
}

// DisableArgs represents the arguments for Disable in the Network domain.
type DisableArgs struct {
}

// Unmarshal the byte array into a return value for Disable in the Network domain.
func (a *DisableArgs) UnmarshalJSON(b []byte) error {
	type Copy DisableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Disable in the Network domain.
func (a *DisableArgs) MarshalJSON() ([]byte, error) {
	type Copy DisableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// DisableReply represents the return values for Disable in the Network domain.
type DisableReply struct {
}

// DisableReply returns whether or not the FrameID matches the reply value for Disable in the Network domain.
func (a *DisableReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: DisableReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for Disable in the Network domain.
func (a *DisableReply) UnmarshalJSON(b []byte) error {
	type Copy DisableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableReply(*c)
	return nil
}

// EmulateNetworkConditionsArgs represents the arguments for EmulateNetworkConditions in the Network domain.
type EmulateNetworkConditionsArgs struct {
	Offline            bool           `json:"offline"`                  // True to emulate internet disconnection.
	Latency            float64        `json:"latency"`                  // Minimum latency from request sent to response headers received (ms).
	DownloadThroughput float64        `json:"downloadThroughput"`       // Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
	UploadThroughput   float64        `json:"uploadThroughput"`         // Maximal aggregated upload throughput (bytes/sec). -1 disables upload throttling.
	ConnectionType     ConnectionType `json:"connectionType,omitempty"` // Connection type if known.
}

// Unmarshal the byte array into a return value for EmulateNetworkConditions in the Network domain.
func (a *EmulateNetworkConditionsArgs) UnmarshalJSON(b []byte) error {
	type Copy EmulateNetworkConditionsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EmulateNetworkConditionsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for EmulateNetworkConditions in the Network domain.
func (a *EmulateNetworkConditionsArgs) MarshalJSON() ([]byte, error) {
	type Copy EmulateNetworkConditionsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EmulateNetworkConditionsReply represents the return values for EmulateNetworkConditions in the Network domain.
type EmulateNetworkConditionsReply struct {
}

// EmulateNetworkConditionsReply returns whether or not the FrameID matches the reply value for EmulateNetworkConditions in the Network domain.
func (a *EmulateNetworkConditionsReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: EmulateNetworkConditionsReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for EmulateNetworkConditions in the Network domain.
func (a *EmulateNetworkConditionsReply) UnmarshalJSON(b []byte) error {
	type Copy EmulateNetworkConditionsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EmulateNetworkConditionsReply(*c)
	return nil
}

// EnableArgs represents the arguments for Enable in the Network domain.
type EnableArgs struct {
	// MaxTotalBufferSize Buffer size in bytes to use when preserving
	// network payloads (XHRs, etc).
	//
	// Note: This property is experimental.
	MaxTotalBufferSize int `json:"maxTotalBufferSize,omitempty"`
	// MaxResourceBufferSize Per-resource buffer size in bytes to use when
	// preserving network payloads (XHRs, etc).
	//
	// Note: This property is experimental.
	MaxResourceBufferSize int `json:"maxResourceBufferSize,omitempty"`
	MaxPostDataSize       int `json:"maxPostDataSize,omitempty"` // Longest post body size (in bytes) that would be included in requestWillBeSent notification
}

// Unmarshal the byte array into a return value for Enable in the Network domain.
func (a *EnableArgs) UnmarshalJSON(b []byte) error {
	type Copy EnableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Enable in the Network domain.
func (a *EnableArgs) MarshalJSON() ([]byte, error) {
	type Copy EnableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EnableReply represents the return values for Enable in the Network domain.
type EnableReply struct {
}

// EnableReply returns whether or not the FrameID matches the reply value for Enable in the Network domain.
func (a *EnableReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: EnableReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for Enable in the Network domain.
func (a *EnableReply) UnmarshalJSON(b []byte) error {
	type Copy EnableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableReply(*c)
	return nil
}

// GetAllCookiesArgs represents the arguments for GetAllCookies in the Network domain.
type GetAllCookiesArgs struct {
}

// Unmarshal the byte array into a return value for GetAllCookies in the Network domain.
func (a *GetAllCookiesArgs) UnmarshalJSON(b []byte) error {
	type Copy GetAllCookiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetAllCookiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetAllCookies in the Network domain.
func (a *GetAllCookiesArgs) MarshalJSON() ([]byte, error) {
	type Copy GetAllCookiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetAllCookiesReply represents the return values for GetAllCookies in the Network domain.
type GetAllCookiesReply struct {
	Cookies []Cookie `json:"cookies"` // Array of cookie objects.
}

// GetAllCookiesReply returns whether or not the FrameID matches the reply value for GetAllCookies in the Network domain.
func (a *GetAllCookiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetAllCookiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetAllCookies in the Network domain.
func (a *GetAllCookiesReply) UnmarshalJSON(b []byte) error {
	type Copy GetAllCookiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetAllCookiesReply(*c)
	return nil
}

// GetCertificateArgs represents the arguments for GetCertificate in the Network domain.
type GetCertificateArgs struct {
	Origin string `json:"origin"` // Origin to get certificate for.
}

// Unmarshal the byte array into a return value for GetCertificate in the Network domain.
func (a *GetCertificateArgs) UnmarshalJSON(b []byte) error {
	type Copy GetCertificateArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetCertificateArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetCertificate in the Network domain.
func (a *GetCertificateArgs) MarshalJSON() ([]byte, error) {
	type Copy GetCertificateArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetCertificateReply represents the return values for GetCertificate in the Network domain.
type GetCertificateReply struct {
	TableNames []string `json:"tableNames"` // No description.
}

// GetCertificateReply returns whether or not the FrameID matches the reply value for GetCertificate in the Network domain.
func (a *GetCertificateReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetCertificateReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetCertificate in the Network domain.
func (a *GetCertificateReply) UnmarshalJSON(b []byte) error {
	type Copy GetCertificateReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetCertificateReply(*c)
	return nil
}

// GetCookiesArgs represents the arguments for GetCookies in the Network domain.
type GetCookiesArgs struct {
	URLs []string `json:"urls,omitempty"` // The list of URLs for which applicable cookies will be fetched
}

// Unmarshal the byte array into a return value for GetCookies in the Network domain.
func (a *GetCookiesArgs) UnmarshalJSON(b []byte) error {
	type Copy GetCookiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetCookiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetCookies in the Network domain.
func (a *GetCookiesArgs) MarshalJSON() ([]byte, error) {
	type Copy GetCookiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetCookiesReply represents the return values for GetCookies in the Network domain.
type GetCookiesReply struct {
	Cookies []Cookie `json:"cookies"` // Array of cookie objects.
}

// GetCookiesReply returns whether or not the FrameID matches the reply value for GetCookies in the Network domain.
func (a *GetCookiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetCookiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetCookies in the Network domain.
func (a *GetCookiesReply) UnmarshalJSON(b []byte) error {
	type Copy GetCookiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetCookiesReply(*c)
	return nil
}

// GetResponseBodyArgs represents the arguments for GetResponseBody in the Network domain.
type GetResponseBodyArgs struct {
	RequestID RequestID `json:"requestId"` // Identifier of the network request to get content for.
}

// Unmarshal the byte array into a return value for GetResponseBody in the Network domain.
func (a *GetResponseBodyArgs) UnmarshalJSON(b []byte) error {
	type Copy GetResponseBodyArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetResponseBodyArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetResponseBody in the Network domain.
func (a *GetResponseBodyArgs) MarshalJSON() ([]byte, error) {
	type Copy GetResponseBodyArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetResponseBodyReply represents the return values for GetResponseBody in the Network domain.
type GetResponseBodyReply struct {
	Body          string `json:"body"`          // Response body.
	Base64Encoded bool   `json:"base64Encoded"` // True, if content was sent as base64.
}

// GetResponseBodyReply returns whether or not the FrameID matches the reply value for GetResponseBody in the Network domain.
func (a *GetResponseBodyReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetResponseBodyReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetResponseBody in the Network domain.
func (a *GetResponseBodyReply) UnmarshalJSON(b []byte) error {
	type Copy GetResponseBodyReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetResponseBodyReply(*c)
	return nil
}

// GetRequestPostDataArgs represents the arguments for GetRequestPostData in the Network domain.
type GetRequestPostDataArgs struct {
	RequestID RequestID `json:"requestId"` // Identifier of the network request to get content for.
}

// Unmarshal the byte array into a return value for GetRequestPostData in the Network domain.
func (a *GetRequestPostDataArgs) UnmarshalJSON(b []byte) error {
	type Copy GetRequestPostDataArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetRequestPostDataArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetRequestPostData in the Network domain.
func (a *GetRequestPostDataArgs) MarshalJSON() ([]byte, error) {
	type Copy GetRequestPostDataArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetRequestPostDataReply represents the return values for GetRequestPostData in the Network domain.
type GetRequestPostDataReply struct {
	PostData []byte `json:"postData"` // Base64-encoded request body.
}

// GetRequestPostDataReply returns whether or not the FrameID matches the reply value for GetRequestPostData in the Network domain.
func (a *GetRequestPostDataReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetRequestPostDataReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetRequestPostData in the Network domain.
func (a *GetRequestPostDataReply) UnmarshalJSON(b []byte) error {
	type Copy GetRequestPostDataReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetRequestPostDataReply(*c)
	return nil
}

// GetResponseBodyForInterceptionArgs represents the arguments for GetResponseBodyForInterception in the Network domain.
type GetResponseBodyForInterceptionArgs struct {
	InterceptionID InterceptionID `json:"interceptionId"` // Identifier for the intercepted request to get body for.
}

// Unmarshal the byte array into a return value for GetResponseBodyForInterception in the Network domain.
func (a *GetResponseBodyForInterceptionArgs) UnmarshalJSON(b []byte) error {
	type Copy GetResponseBodyForInterceptionArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetResponseBodyForInterceptionArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetResponseBodyForInterception in the Network domain.
func (a *GetResponseBodyForInterceptionArgs) MarshalJSON() ([]byte, error) {
	type Copy GetResponseBodyForInterceptionArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetResponseBodyForInterceptionReply represents the return values for GetResponseBodyForInterception in the Network domain.
type GetResponseBodyForInterceptionReply struct {
	Body          string `json:"body"`          // Response body.
	Base64Encoded bool   `json:"base64Encoded"` // True, if content was sent as base64.
}

// GetResponseBodyForInterceptionReply returns whether or not the FrameID matches the reply value for GetResponseBodyForInterception in the Network domain.
func (a *GetResponseBodyForInterceptionReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetResponseBodyForInterceptionReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetResponseBodyForInterception in the Network domain.
func (a *GetResponseBodyForInterceptionReply) UnmarshalJSON(b []byte) error {
	type Copy GetResponseBodyForInterceptionReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetResponseBodyForInterceptionReply(*c)
	return nil
}

// TakeResponseBodyForInterceptionAsStreamArgs represents the arguments for TakeResponseBodyForInterceptionAsStream in the Network domain.
type TakeResponseBodyForInterceptionAsStreamArgs struct {
	InterceptionID InterceptionID `json:"interceptionId"` // No description.
}

// Unmarshal the byte array into a return value for TakeResponseBodyForInterceptionAsStream in the Network domain.
func (a *TakeResponseBodyForInterceptionAsStreamArgs) UnmarshalJSON(b []byte) error {
	type Copy TakeResponseBodyForInterceptionAsStreamArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = TakeResponseBodyForInterceptionAsStreamArgs(*c)
	return nil
}

// Marshall the byte array into a return value for TakeResponseBodyForInterceptionAsStream in the Network domain.
func (a *TakeResponseBodyForInterceptionAsStreamArgs) MarshalJSON() ([]byte, error) {
	type Copy TakeResponseBodyForInterceptionAsStreamArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// TakeResponseBodyForInterceptionAsStreamReply represents the return values for TakeResponseBodyForInterceptionAsStream in the Network domain.
type TakeResponseBodyForInterceptionAsStreamReply struct {
	Stream io.StreamHandle `json:"stream"` // No description.
}

// TakeResponseBodyForInterceptionAsStreamReply returns whether or not the FrameID matches the reply value for TakeResponseBodyForInterceptionAsStream in the Network domain.
func (a *TakeResponseBodyForInterceptionAsStreamReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: TakeResponseBodyForInterceptionAsStreamReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for TakeResponseBodyForInterceptionAsStream in the Network domain.
func (a *TakeResponseBodyForInterceptionAsStreamReply) UnmarshalJSON(b []byte) error {
	type Copy TakeResponseBodyForInterceptionAsStreamReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = TakeResponseBodyForInterceptionAsStreamReply(*c)
	return nil
}

// ReplayXHRArgs represents the arguments for ReplayXHR in the Network domain.
type ReplayXHRArgs struct {
	RequestID RequestID `json:"requestId"` // Identifier of XHR to replay.
}

// Unmarshal the byte array into a return value for ReplayXHR in the Network domain.
func (a *ReplayXHRArgs) UnmarshalJSON(b []byte) error {
	type Copy ReplayXHRArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ReplayXHRArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ReplayXHR in the Network domain.
func (a *ReplayXHRArgs) MarshalJSON() ([]byte, error) {
	type Copy ReplayXHRArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ReplayXHRReply represents the return values for ReplayXHR in the Network domain.
type ReplayXHRReply struct {
}

// ReplayXHRReply returns whether or not the FrameID matches the reply value for ReplayXHR in the Network domain.
func (a *ReplayXHRReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ReplayXHRReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for ReplayXHR in the Network domain.
func (a *ReplayXHRReply) UnmarshalJSON(b []byte) error {
	type Copy ReplayXHRReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ReplayXHRReply(*c)
	return nil
}

// SearchInResponseBodyArgs represents the arguments for SearchInResponseBody in the Network domain.
type SearchInResponseBodyArgs struct {
	RequestID     RequestID `json:"requestId"`               // Identifier of the network response to search.
	Query         string    `json:"query"`                   // String to search for.
	CaseSensitive bool      `json:"caseSensitive,omitempty"` // If true, search is case sensitive.
	IsRegex       bool      `json:"isRegex,omitempty"`       // If true, treats string parameter as regex.
}

// Unmarshal the byte array into a return value for SearchInResponseBody in the Network domain.
func (a *SearchInResponseBodyArgs) UnmarshalJSON(b []byte) error {
	type Copy SearchInResponseBodyArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SearchInResponseBodyArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SearchInResponseBody in the Network domain.
func (a *SearchInResponseBodyArgs) MarshalJSON() ([]byte, error) {
	type Copy SearchInResponseBodyArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SearchInResponseBodyReply represents the return values for SearchInResponseBody in the Network domain.
type SearchInResponseBodyReply struct {
	Result []debugger.SearchMatch `json:"result"` // List of search matches.
}

// SearchInResponseBodyReply returns whether or not the FrameID matches the reply value for SearchInResponseBody in the Network domain.
func (a *SearchInResponseBodyReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SearchInResponseBodyReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SearchInResponseBody in the Network domain.
func (a *SearchInResponseBodyReply) UnmarshalJSON(b []byte) error {
	type Copy SearchInResponseBodyReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SearchInResponseBodyReply(*c)
	return nil
}

// SetBlockedURLsArgs represents the arguments for SetBlockedURLs in the Network domain.
type SetBlockedURLsArgs struct {
	URLs []string `json:"urls"` // URL patterns to block. Wildcards ('*') are allowed.
}

// Unmarshal the byte array into a return value for SetBlockedURLs in the Network domain.
func (a *SetBlockedURLsArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBlockedURLsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBlockedURLsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBlockedURLs in the Network domain.
func (a *SetBlockedURLsArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBlockedURLsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBlockedURLsReply represents the return values for SetBlockedURLs in the Network domain.
type SetBlockedURLsReply struct {
}

// SetBlockedURLsReply returns whether or not the FrameID matches the reply value for SetBlockedURLs in the Network domain.
func (a *SetBlockedURLsReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetBlockedURLsReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetBlockedURLs in the Network domain.
func (a *SetBlockedURLsReply) UnmarshalJSON(b []byte) error {
	type Copy SetBlockedURLsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBlockedURLsReply(*c)
	return nil
}

// SetBypassServiceWorkerArgs represents the arguments for SetBypassServiceWorker in the Network domain.
type SetBypassServiceWorkerArgs struct {
	Bypass bool `json:"bypass"` // Bypass service worker and load from network.
}

// Unmarshal the byte array into a return value for SetBypassServiceWorker in the Network domain.
func (a *SetBypassServiceWorkerArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBypassServiceWorkerArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBypassServiceWorkerArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBypassServiceWorker in the Network domain.
func (a *SetBypassServiceWorkerArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBypassServiceWorkerArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBypassServiceWorkerReply represents the return values for SetBypassServiceWorker in the Network domain.
type SetBypassServiceWorkerReply struct {
}

// SetBypassServiceWorkerReply returns whether or not the FrameID matches the reply value for SetBypassServiceWorker in the Network domain.
func (a *SetBypassServiceWorkerReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetBypassServiceWorkerReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetBypassServiceWorker in the Network domain.
func (a *SetBypassServiceWorkerReply) UnmarshalJSON(b []byte) error {
	type Copy SetBypassServiceWorkerReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBypassServiceWorkerReply(*c)
	return nil
}

// SetCacheDisabledArgs represents the arguments for SetCacheDisabled in the Network domain.
type SetCacheDisabledArgs struct {
	CacheDisabled bool `json:"cacheDisabled"` // Cache disabled state.
}

// Unmarshal the byte array into a return value for SetCacheDisabled in the Network domain.
func (a *SetCacheDisabledArgs) UnmarshalJSON(b []byte) error {
	type Copy SetCacheDisabledArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCacheDisabledArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetCacheDisabled in the Network domain.
func (a *SetCacheDisabledArgs) MarshalJSON() ([]byte, error) {
	type Copy SetCacheDisabledArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetCacheDisabledReply represents the return values for SetCacheDisabled in the Network domain.
type SetCacheDisabledReply struct {
}

// SetCacheDisabledReply returns whether or not the FrameID matches the reply value for SetCacheDisabled in the Network domain.
func (a *SetCacheDisabledReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetCacheDisabledReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetCacheDisabled in the Network domain.
func (a *SetCacheDisabledReply) UnmarshalJSON(b []byte) error {
	type Copy SetCacheDisabledReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCacheDisabledReply(*c)
	return nil
}

// SetCookieArgs represents the arguments for SetCookie in the Network domain.
type SetCookieArgs struct {
	Name     string         `json:"name"`               // Cookie name.
	Value    string         `json:"value"`              // Cookie value.
	URL      string         `json:"url,omitempty"`      // The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie.
	Domain   string         `json:"domain,omitempty"`   // Cookie domain.
	Path     string         `json:"path,omitempty"`     // Cookie path.
	Secure   bool           `json:"secure,omitempty"`   // True if cookie is secure.
	HTTPOnly bool           `json:"httpOnly,omitempty"` // True if cookie is http-only.
	SameSite CookieSameSite `json:"sameSite,omitempty"` // Cookie SameSite type.
	Expires  TimeSinceEpoch `json:"expires,omitempty"`  // Cookie expiration date, session cookie if not set
}

// Unmarshal the byte array into a return value for SetCookie in the Network domain.
func (a *SetCookieArgs) UnmarshalJSON(b []byte) error {
	type Copy SetCookieArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCookieArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetCookie in the Network domain.
func (a *SetCookieArgs) MarshalJSON() ([]byte, error) {
	type Copy SetCookieArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetCookieReply represents the return values for SetCookie in the Network domain.
type SetCookieReply struct {
	Success bool `json:"success"` // True if successfully set cookie.
}

// SetCookieReply returns whether or not the FrameID matches the reply value for SetCookie in the Network domain.
func (a *SetCookieReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetCookieReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetCookie in the Network domain.
func (a *SetCookieReply) UnmarshalJSON(b []byte) error {
	type Copy SetCookieReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCookieReply(*c)
	return nil
}

// SetCookiesArgs represents the arguments for SetCookies in the Network domain.
type SetCookiesArgs struct {
	Cookies []CookieParam `json:"cookies"` // Cookies to be set.
}

// Unmarshal the byte array into a return value for SetCookies in the Network domain.
func (a *SetCookiesArgs) UnmarshalJSON(b []byte) error {
	type Copy SetCookiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCookiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetCookies in the Network domain.
func (a *SetCookiesArgs) MarshalJSON() ([]byte, error) {
	type Copy SetCookiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetCookiesReply represents the return values for SetCookies in the Network domain.
type SetCookiesReply struct {
}

// SetCookiesReply returns whether or not the FrameID matches the reply value for SetCookies in the Network domain.
func (a *SetCookiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetCookiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetCookies in the Network domain.
func (a *SetCookiesReply) UnmarshalJSON(b []byte) error {
	type Copy SetCookiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCookiesReply(*c)
	return nil
}

// SetDataSizeLimitsForTestArgs represents the arguments for SetDataSizeLimitsForTest in the Network domain.
type SetDataSizeLimitsForTestArgs struct {
	MaxTotalSize    int `json:"maxTotalSize"`    // Maximum total buffer size.
	MaxResourceSize int `json:"maxResourceSize"` // Maximum per-resource size.
}

// Unmarshal the byte array into a return value for SetDataSizeLimitsForTest in the Network domain.
func (a *SetDataSizeLimitsForTestArgs) UnmarshalJSON(b []byte) error {
	type Copy SetDataSizeLimitsForTestArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetDataSizeLimitsForTestArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetDataSizeLimitsForTest in the Network domain.
func (a *SetDataSizeLimitsForTestArgs) MarshalJSON() ([]byte, error) {
	type Copy SetDataSizeLimitsForTestArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetDataSizeLimitsForTestReply represents the return values for SetDataSizeLimitsForTest in the Network domain.
type SetDataSizeLimitsForTestReply struct {
}

// SetDataSizeLimitsForTestReply returns whether or not the FrameID matches the reply value for SetDataSizeLimitsForTest in the Network domain.
func (a *SetDataSizeLimitsForTestReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetDataSizeLimitsForTestReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetDataSizeLimitsForTest in the Network domain.
func (a *SetDataSizeLimitsForTestReply) UnmarshalJSON(b []byte) error {
	type Copy SetDataSizeLimitsForTestReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetDataSizeLimitsForTestReply(*c)
	return nil
}

// SetExtraHTTPHeadersArgs represents the arguments for SetExtraHTTPHeaders in the Network domain.
type SetExtraHTTPHeadersArgs struct {
	Headers Headers `json:"headers"` // Map with extra HTTP headers.
}

// Unmarshal the byte array into a return value for SetExtraHTTPHeaders in the Network domain.
func (a *SetExtraHTTPHeadersArgs) UnmarshalJSON(b []byte) error {
	type Copy SetExtraHTTPHeadersArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetExtraHTTPHeadersArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetExtraHTTPHeaders in the Network domain.
func (a *SetExtraHTTPHeadersArgs) MarshalJSON() ([]byte, error) {
	type Copy SetExtraHTTPHeadersArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetExtraHTTPHeadersReply represents the return values for SetExtraHTTPHeaders in the Network domain.
type SetExtraHTTPHeadersReply struct {
}

// SetExtraHTTPHeadersReply returns whether or not the FrameID matches the reply value for SetExtraHTTPHeaders in the Network domain.
func (a *SetExtraHTTPHeadersReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetExtraHTTPHeadersReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetExtraHTTPHeaders in the Network domain.
func (a *SetExtraHTTPHeadersReply) UnmarshalJSON(b []byte) error {
	type Copy SetExtraHTTPHeadersReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetExtraHTTPHeadersReply(*c)
	return nil
}

// SetRequestInterceptionArgs represents the arguments for SetRequestInterception in the Network domain.
type SetRequestInterceptionArgs struct {
	Patterns []RequestPattern `json:"patterns"` // Requests matching any of these patterns will be forwarded and wait for the corresponding continueInterceptedRequest call.
}

// Unmarshal the byte array into a return value for SetRequestInterception in the Network domain.
func (a *SetRequestInterceptionArgs) UnmarshalJSON(b []byte) error {
	type Copy SetRequestInterceptionArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetRequestInterceptionArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetRequestInterception in the Network domain.
func (a *SetRequestInterceptionArgs) MarshalJSON() ([]byte, error) {
	type Copy SetRequestInterceptionArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetRequestInterceptionReply represents the return values for SetRequestInterception in the Network domain.
type SetRequestInterceptionReply struct {
}

// SetRequestInterceptionReply returns whether or not the FrameID matches the reply value for SetRequestInterception in the Network domain.
func (a *SetRequestInterceptionReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetRequestInterceptionReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetRequestInterception in the Network domain.
func (a *SetRequestInterceptionReply) UnmarshalJSON(b []byte) error {
	type Copy SetRequestInterceptionReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetRequestInterceptionReply(*c)
	return nil
}
