// Code generated by cdpgen. DO NOT EDIT.

package tracing

import (
	"encoding/json"
	"log"
)

const CommandTracingEnd = "Tracing.end"

// EndArgs represents the arguments for End in the Tracing domain.
type EndArgs struct {
}

// Unmarshal the byte array into a return value for End in the Tracing domain.
func (a *EndArgs) UnmarshalJSON(b []byte) error {
	type Copy EndArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EndArgs(*c)
	return nil
}

// Marshall the byte array into a return value for End in the Tracing domain.
func (a *EndArgs) MarshalJSON() ([]byte, error) {
	type Copy EndArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EndReply represents the return values for End in the Tracing domain.
type EndReply struct {
}

// EndReply returns whether or not the FrameID matches the reply value for End in the Tracing domain.
func (a *EndReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: EndReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for End in the Tracing domain.
func (a *EndReply) UnmarshalJSON(b []byte) error {
	type Copy EndReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EndReply(*c)
	return nil
}

const CommandTracingGetCategories = "Tracing.getCategories"

// GetCategoriesArgs represents the arguments for GetCategories in the Tracing domain.
type GetCategoriesArgs struct {
}

// Unmarshal the byte array into a return value for GetCategories in the Tracing domain.
func (a *GetCategoriesArgs) UnmarshalJSON(b []byte) error {
	type Copy GetCategoriesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetCategoriesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetCategories in the Tracing domain.
func (a *GetCategoriesArgs) MarshalJSON() ([]byte, error) {
	type Copy GetCategoriesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetCategoriesReply represents the return values for GetCategories in the Tracing domain.
type GetCategoriesReply struct {
	Categories []string `json:"categories"` // A list of supported tracing categories.
}

// GetCategoriesReply returns whether or not the FrameID matches the reply value for GetCategories in the Tracing domain.
func (a *GetCategoriesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetCategoriesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetCategories in the Tracing domain.
func (a *GetCategoriesReply) UnmarshalJSON(b []byte) error {
	type Copy GetCategoriesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetCategoriesReply(*c)
	return nil
}

const CommandTracingRecordClockSyncMarker = "Tracing.recordClockSyncMarker"

// RecordClockSyncMarkerArgs represents the arguments for RecordClockSyncMarker in the Tracing domain.
type RecordClockSyncMarkerArgs struct {
	SyncID string `json:"syncId"` // The ID of this clock sync marker
}

// Unmarshal the byte array into a return value for RecordClockSyncMarker in the Tracing domain.
func (a *RecordClockSyncMarkerArgs) UnmarshalJSON(b []byte) error {
	type Copy RecordClockSyncMarkerArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RecordClockSyncMarkerArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RecordClockSyncMarker in the Tracing domain.
func (a *RecordClockSyncMarkerArgs) MarshalJSON() ([]byte, error) {
	type Copy RecordClockSyncMarkerArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RecordClockSyncMarkerReply represents the return values for RecordClockSyncMarker in the Tracing domain.
type RecordClockSyncMarkerReply struct {
}

// RecordClockSyncMarkerReply returns whether or not the FrameID matches the reply value for RecordClockSyncMarker in the Tracing domain.
func (a *RecordClockSyncMarkerReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RecordClockSyncMarkerReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for RecordClockSyncMarker in the Tracing domain.
func (a *RecordClockSyncMarkerReply) UnmarshalJSON(b []byte) error {
	type Copy RecordClockSyncMarkerReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RecordClockSyncMarkerReply(*c)
	return nil
}

const CommandTracingRequestMemoryDump = "Tracing.requestMemoryDump"

// RequestMemoryDumpArgs represents the arguments for RequestMemoryDump in the Tracing domain.
type RequestMemoryDumpArgs struct {
}

// Unmarshal the byte array into a return value for RequestMemoryDump in the Tracing domain.
func (a *RequestMemoryDumpArgs) UnmarshalJSON(b []byte) error {
	type Copy RequestMemoryDumpArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RequestMemoryDumpArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RequestMemoryDump in the Tracing domain.
func (a *RequestMemoryDumpArgs) MarshalJSON() ([]byte, error) {
	type Copy RequestMemoryDumpArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RequestMemoryDumpReply represents the return values for RequestMemoryDump in the Tracing domain.
type RequestMemoryDumpReply struct {
	DumpGUID string `json:"dumpGuid"` // GUID of the resulting global memory dump.
	Success  bool   `json:"success"`  // True iff the global memory dump succeeded.
}

// RequestMemoryDumpReply returns whether or not the FrameID matches the reply value for RequestMemoryDump in the Tracing domain.
func (a *RequestMemoryDumpReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RequestMemoryDumpReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for RequestMemoryDump in the Tracing domain.
func (a *RequestMemoryDumpReply) UnmarshalJSON(b []byte) error {
	type Copy RequestMemoryDumpReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RequestMemoryDumpReply(*c)
	return nil
}

const CommandTracingStart = "Tracing.start"

// StartArgs represents the arguments for Start in the Tracing domain.
type StartArgs struct {
	// Categories is deprecated.
	//
	// Deprecated: Category/tag filter
	Categories string `json:"categories,omitempty"`
	// Options is deprecated.
	//
	// Deprecated: Tracing options
	Options                      string  `json:"options,omitempty"`
	BufferUsageReportingInterval float64 `json:"bufferUsageReportingInterval,omitempty"` // If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
	// TransferMode Whether to report trace events as series of
	// dataCollected events or to save trace to a stream (defaults to
	// `ReportEvents`).
	//
	// Values: "ReportEvents", "ReturnAsStream".
	TransferMode      string            `json:"transferMode,omitempty"`
	StreamCompression StreamCompression `json:"streamCompression,omitempty"` // Compression format to use. This only applies when using `ReturnAsStream` transfer mode (defaults to `none`)
	TraceConfig       TraceConfig       `json:"traceConfig,omitempty"`       // No description.
}

// Unmarshal the byte array into a return value for Start in the Tracing domain.
func (a *StartArgs) UnmarshalJSON(b []byte) error {
	type Copy StartArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StartArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Start in the Tracing domain.
func (a *StartArgs) MarshalJSON() ([]byte, error) {
	type Copy StartArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// StartReply represents the return values for Start in the Tracing domain.
type StartReply struct {
}

// StartReply returns whether or not the FrameID matches the reply value for Start in the Tracing domain.
func (a *StartReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: StartReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for Start in the Tracing domain.
func (a *StartReply) UnmarshalJSON(b []byte) error {
	type Copy StartReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StartReply(*c)
	return nil
}
