// Code generated by cdpgen. DO NOT EDIT.

package tracing

import (
	"encoding/json"
	"log"

	"github.com/4ydx/cdp/protocol/io"
)

const (
	EventTracingBufferUsage     = "Tracing.bufferUsage"
	EventTracingDataCollected   = "Tracing.dataCollected"
	EventTracingTracingComplete = "Tracing.tracingComplete"
)

type Unmarshaler func() json.Unmarshaler

var EventConstants = map[string]Unmarshaler{
	EventTracingBufferUsage:     func() json.Unmarshaler { return &BufferUsageReply{} },
	EventTracingDataCollected:   func() json.Unmarshaler { return &DataCollectedReply{} },
	EventTracingTracingComplete: func() json.Unmarshaler { return &CompleteReply{} },
}

func GetEventReply(event string) (json.Unmarshaler, bool) {
	e, ok := EventConstants[event]
	if ok {
		return e(), ok
	}
	return nil, ok
}

// BufferUsageReply is the reply for BufferUsage events.
type BufferUsageReply struct {
	PercentFull float64 `json:"percentFull,omitempty"` // A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size.
	EventCount  float64 `json:"eventCount,omitempty"`  // An approximate number of events in the trace log.
	Value       float64 `json:"value,omitempty"`       // A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size.
}

// Unmarshal the byte array into a return value for BufferUsage in the Tracing domain.
func (a *BufferUsageReply) UnmarshalJSON(b []byte) error {
	type Copy BufferUsageReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = BufferUsageReply(*c)
	return nil
}

// BufferUsageReply returns whether or not the FrameID matches the reply value for BufferUsage in the Tracing domain.
func (a *BufferUsageReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: BufferUsageReply %s", err)
		return false, err
	}
	return true, nil
}

// BufferUsageReply returns the FrameID for BufferUsage in the Tracing domain.
func (a *BufferUsageReply) GetFrameID() string {
	return ""
}

// DataCollectedReply is the reply for DataCollected events.
type DataCollectedReply struct {
	Value []json.RawMessage `json:"value"` // No description.
}

// Unmarshal the byte array into a return value for DataCollected in the Tracing domain.
func (a *DataCollectedReply) UnmarshalJSON(b []byte) error {
	type Copy DataCollectedReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DataCollectedReply(*c)
	return nil
}

// DataCollectedReply returns whether or not the FrameID matches the reply value for DataCollected in the Tracing domain.
func (a *DataCollectedReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: DataCollectedReply %s", err)
		return false, err
	}
	return true, nil
}

// DataCollectedReply returns the FrameID for DataCollected in the Tracing domain.
func (a *DataCollectedReply) GetFrameID() string {
	return ""
}

// CompleteReply is the reply for TracingComplete events.
type CompleteReply struct {
	DataLossOccurred  bool               `json:"dataLossOccurred"`            // Indicates whether some trace data is known to have been lost, e.g. because the trace ring buffer wrapped around.
	Stream            *io.StreamHandle   `json:"stream,omitempty"`            // A handle of the stream that holds resulting trace data.
	TraceFormat       *StreamFormat      `json:"traceFormat,omitempty"`       // Trace data format of returned stream.
	StreamCompression *StreamCompression `json:"streamCompression,omitempty"` // Compression format of returned stream.
}

// Unmarshal the byte array into a return value for TracingComplete in the Tracing domain.
func (a *CompleteReply) UnmarshalJSON(b []byte) error {
	type Copy CompleteReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CompleteReply(*c)
	return nil
}

// CompleteReply returns whether or not the FrameID matches the reply value for TracingComplete in the Tracing domain.
func (a *CompleteReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: CompleteReply %s", err)
		return false, err
	}
	return true, nil
}

// CompleteReply returns the FrameID for TracingComplete in the Tracing domain.
func (a *CompleteReply) GetFrameID() string {
	return ""
}
