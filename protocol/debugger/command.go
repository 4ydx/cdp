// Code generated by cdpgen. DO NOT EDIT.

package debugger

import (
	"encoding/json"
	"log"

	shared "github.com/4ydx/cdp/protocol"
	"github.com/4ydx/cdp/protocol/runtime"
)

const (
	CommandDebuggerContinueToLocation           = "Debugger.continueToLocation"
	CommandDebuggerDisable                      = "Debugger.disable"
	CommandDebuggerEnable                       = "Debugger.enable"
	CommandDebuggerEvaluateOnCallFrame          = "Debugger.evaluateOnCallFrame"
	CommandDebuggerGetPossibleBreakpoints       = "Debugger.getPossibleBreakpoints"
	CommandDebuggerGetScriptSource              = "Debugger.getScriptSource"
	CommandDebuggerGetWasmBytecode              = "Debugger.getWasmBytecode"
	CommandDebuggerGetStackTrace                = "Debugger.getStackTrace"
	CommandDebuggerPause                        = "Debugger.pause"
	CommandDebuggerPauseOnAsyncCall             = "Debugger.pauseOnAsyncCall"
	CommandDebuggerRemoveBreakpoint             = "Debugger.removeBreakpoint"
	CommandDebuggerRestartFrame                 = "Debugger.restartFrame"
	CommandDebuggerResume                       = "Debugger.resume"
	CommandDebuggerSearchInContent              = "Debugger.searchInContent"
	CommandDebuggerSetAsyncCallStackDepth       = "Debugger.setAsyncCallStackDepth"
	CommandDebuggerSetBlackboxPatterns          = "Debugger.setBlackboxPatterns"
	CommandDebuggerSetBlackboxedRanges          = "Debugger.setBlackboxedRanges"
	CommandDebuggerSetBreakpoint                = "Debugger.setBreakpoint"
	CommandDebuggerSetInstrumentationBreakpoint = "Debugger.setInstrumentationBreakpoint"
	CommandDebuggerSetBreakpointByUrl           = "Debugger.setBreakpointByUrl"
	CommandDebuggerSetBreakpointOnFunctionCall  = "Debugger.setBreakpointOnFunctionCall"
	CommandDebuggerSetBreakpointsActive         = "Debugger.setBreakpointsActive"
	CommandDebuggerSetPauseOnExceptions         = "Debugger.setPauseOnExceptions"
	CommandDebuggerSetReturnValue               = "Debugger.setReturnValue"
	CommandDebuggerSetScriptSource              = "Debugger.setScriptSource"
	CommandDebuggerSetSkipAllPauses             = "Debugger.setSkipAllPauses"
	CommandDebuggerSetVariableValue             = "Debugger.setVariableValue"
	CommandDebuggerStepInto                     = "Debugger.stepInto"
	CommandDebuggerStepOut                      = "Debugger.stepOut"
	CommandDebuggerStepOver                     = "Debugger.stepOver"
)

// ContinueToLocationArgs represents the arguments for ContinueToLocation in the Debugger domain.
type ContinueToLocationArgs struct {
	Location Location `json:"location"` // Location to continue to.
	// TargetCallFrames
	//
	// Values: "any", "current".
	TargetCallFrames string `json:"targetCallFrames,omitempty"`
}

// Unmarshal the byte array into a return value for ContinueToLocation in the Debugger domain.
func (a *ContinueToLocationArgs) UnmarshalJSON(b []byte) error {
	type Copy ContinueToLocationArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueToLocationArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ContinueToLocation in the Debugger domain.
func (a *ContinueToLocationArgs) MarshalJSON() ([]byte, error) {
	type Copy ContinueToLocationArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ContinueToLocationReply represents the return values for ContinueToLocation in the Debugger domain.
type ContinueToLocationReply struct {
}

// ContinueToLocationReply returns whether or not the FrameID matches the reply value for ContinueToLocation in the Debugger domain.
func (a *ContinueToLocationReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: ContinueToLocationReply %s", err)
		return false, err
	}
	return true, nil
}

// ContinueToLocationReply returns the FrameID value for ContinueToLocation in the Debugger domain.
func (a *ContinueToLocationReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for ContinueToLocation in the Debugger domain.
func (a *ContinueToLocationReply) UnmarshalJSON(b []byte) error {
	type Copy ContinueToLocationReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ContinueToLocationReply(*c)
	return nil
}

// DisableArgs represents the arguments for Disable in the Debugger domain.
type DisableArgs struct {
}

// Unmarshal the byte array into a return value for Disable in the Debugger domain.
func (a *DisableArgs) UnmarshalJSON(b []byte) error {
	type Copy DisableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Disable in the Debugger domain.
func (a *DisableArgs) MarshalJSON() ([]byte, error) {
	type Copy DisableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// DisableReply represents the return values for Disable in the Debugger domain.
type DisableReply struct {
}

// DisableReply returns whether or not the FrameID matches the reply value for Disable in the Debugger domain.
func (a *DisableReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: DisableReply %s", err)
		return false, err
	}
	return true, nil
}

// DisableReply returns the FrameID value for Disable in the Debugger domain.
func (a *DisableReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for Disable in the Debugger domain.
func (a *DisableReply) UnmarshalJSON(b []byte) error {
	type Copy DisableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableReply(*c)
	return nil
}

// EnableArgs represents the arguments for Enable in the Debugger domain.
type EnableArgs struct {
	// MaxScriptsCacheSize The maximum size in bytes of collected scripts
	// (not referenced by other heap objects) the debugger can hold. Puts
	// no limit if parameter is omitted.
	//
	// Note: This property is experimental.
	MaxScriptsCacheSize float64 `json:"maxScriptsCacheSize,omitempty"`
}

// Unmarshal the byte array into a return value for Enable in the Debugger domain.
func (a *EnableArgs) UnmarshalJSON(b []byte) error {
	type Copy EnableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Enable in the Debugger domain.
func (a *EnableArgs) MarshalJSON() ([]byte, error) {
	type Copy EnableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EnableReply represents the return values for Enable in the Debugger domain.
type EnableReply struct {
	// DebuggerID Unique identifier of the debugger.
	//
	// Note: This property is experimental.
	DebuggerID runtime.UniqueDebuggerID `json:"debuggerId"`
}

// EnableReply returns whether or not the FrameID matches the reply value for Enable in the Debugger domain.
func (a *EnableReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: EnableReply %s", err)
		return false, err
	}
	return true, nil
}

// EnableReply returns the FrameID value for Enable in the Debugger domain.
func (a *EnableReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for Enable in the Debugger domain.
func (a *EnableReply) UnmarshalJSON(b []byte) error {
	type Copy EnableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableReply(*c)
	return nil
}

// EvaluateOnCallFrameArgs represents the arguments for EvaluateOnCallFrame in the Debugger domain.
type EvaluateOnCallFrameArgs struct {
	CallFrameID           CallFrameID `json:"callFrameId"`                     // Call frame identifier to evaluate on.
	Expression            string      `json:"expression"`                      // Expression to evaluate.
	ObjectGroup           string      `json:"objectGroup,omitempty"`           // String object group name to put result into (allows rapid releasing resulting object handles using `releaseObjectGroup`).
	IncludeCommandLineAPI bool        `json:"includeCommandLineAPI,omitempty"` // Specifies whether command line API should be available to the evaluated expression, defaults to false.
	Silent                bool        `json:"silent,omitempty"`                // In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
	ReturnByValue         bool        `json:"returnByValue,omitempty"`         // Whether the result is expected to be a JSON object that should be sent by value.
	// GeneratePreview Whether preview should be generated for the result.
	//
	// Note: This property is experimental.
	GeneratePreview   bool `json:"generatePreview,omitempty"`
	ThrowOnSideEffect bool `json:"throwOnSideEffect,omitempty"` // Whether to throw an exception if side effect cannot be ruled out during evaluation.
	// Timeout Terminate execution after timing out (number of
	// milliseconds).
	//
	// Note: This property is experimental.
	Timeout *runtime.TimeDelta `json:"timeout,omitempty"`
}

// Unmarshal the byte array into a return value for EvaluateOnCallFrame in the Debugger domain.
func (a *EvaluateOnCallFrameArgs) UnmarshalJSON(b []byte) error {
	type Copy EvaluateOnCallFrameArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EvaluateOnCallFrameArgs(*c)
	return nil
}

// Marshall the byte array into a return value for EvaluateOnCallFrame in the Debugger domain.
func (a *EvaluateOnCallFrameArgs) MarshalJSON() ([]byte, error) {
	type Copy EvaluateOnCallFrameArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EvaluateOnCallFrameReply represents the return values for EvaluateOnCallFrame in the Debugger domain.
type EvaluateOnCallFrameReply struct {
	Result           runtime.RemoteObject      `json:"result"`                     // Object wrapper for the evaluation result.
	ExceptionDetails *runtime.ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details.
}

// EvaluateOnCallFrameReply returns whether or not the FrameID matches the reply value for EvaluateOnCallFrame in the Debugger domain.
func (a *EvaluateOnCallFrameReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: EvaluateOnCallFrameReply %s", err)
		return false, err
	}
	return true, nil
}

// EvaluateOnCallFrameReply returns the FrameID value for EvaluateOnCallFrame in the Debugger domain.
func (a *EvaluateOnCallFrameReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for EvaluateOnCallFrame in the Debugger domain.
func (a *EvaluateOnCallFrameReply) UnmarshalJSON(b []byte) error {
	type Copy EvaluateOnCallFrameReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EvaluateOnCallFrameReply(*c)
	return nil
}

// GetPossibleBreakpointsArgs represents the arguments for GetPossibleBreakpoints in the Debugger domain.
type GetPossibleBreakpointsArgs struct {
	Start              Location  `json:"start"`                        // Start of range to search possible breakpoint locations in.
	End                *Location `json:"end,omitempty"`                // End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
	RestrictToFunction bool      `json:"restrictToFunction,omitempty"` // Only consider locations which are in the same (non-nested) function as start.
}

// Unmarshal the byte array into a return value for GetPossibleBreakpoints in the Debugger domain.
func (a *GetPossibleBreakpointsArgs) UnmarshalJSON(b []byte) error {
	type Copy GetPossibleBreakpointsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetPossibleBreakpointsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetPossibleBreakpoints in the Debugger domain.
func (a *GetPossibleBreakpointsArgs) MarshalJSON() ([]byte, error) {
	type Copy GetPossibleBreakpointsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetPossibleBreakpointsReply represents the return values for GetPossibleBreakpoints in the Debugger domain.
type GetPossibleBreakpointsReply struct {
	Locations []BreakLocation `json:"locations"` // List of the possible breakpoint locations.
}

// GetPossibleBreakpointsReply returns whether or not the FrameID matches the reply value for GetPossibleBreakpoints in the Debugger domain.
func (a *GetPossibleBreakpointsReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: GetPossibleBreakpointsReply %s", err)
		return false, err
	}
	return true, nil
}

// GetPossibleBreakpointsReply returns the FrameID value for GetPossibleBreakpoints in the Debugger domain.
func (a *GetPossibleBreakpointsReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for GetPossibleBreakpoints in the Debugger domain.
func (a *GetPossibleBreakpointsReply) UnmarshalJSON(b []byte) error {
	type Copy GetPossibleBreakpointsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetPossibleBreakpointsReply(*c)
	return nil
}

// GetScriptSourceArgs represents the arguments for GetScriptSource in the Debugger domain.
type GetScriptSourceArgs struct {
	ScriptID runtime.ScriptID `json:"scriptId"` // Id of the script to get source for.
}

// Unmarshal the byte array into a return value for GetScriptSource in the Debugger domain.
func (a *GetScriptSourceArgs) UnmarshalJSON(b []byte) error {
	type Copy GetScriptSourceArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetScriptSourceArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetScriptSource in the Debugger domain.
func (a *GetScriptSourceArgs) MarshalJSON() ([]byte, error) {
	type Copy GetScriptSourceArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetScriptSourceReply represents the return values for GetScriptSource in the Debugger domain.
type GetScriptSourceReply struct {
	ScriptSource string `json:"scriptSource"`       // Script source (empty in case of Wasm bytecode).
	Bytecode     string `json:"bytecode,omitempty"` // Wasm bytecode.
}

// GetScriptSourceReply returns whether or not the FrameID matches the reply value for GetScriptSource in the Debugger domain.
func (a *GetScriptSourceReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: GetScriptSourceReply %s", err)
		return false, err
	}
	return true, nil
}

// GetScriptSourceReply returns the FrameID value for GetScriptSource in the Debugger domain.
func (a *GetScriptSourceReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for GetScriptSource in the Debugger domain.
func (a *GetScriptSourceReply) UnmarshalJSON(b []byte) error {
	type Copy GetScriptSourceReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetScriptSourceReply(*c)
	return nil
}

// GetWasmBytecodeArgs represents the arguments for GetWasmBytecode in the Debugger domain.
type GetWasmBytecodeArgs struct {
	ScriptID runtime.ScriptID `json:"scriptId"` // Id of the Wasm script to get source for.
}

// Unmarshal the byte array into a return value for GetWasmBytecode in the Debugger domain.
func (a *GetWasmBytecodeArgs) UnmarshalJSON(b []byte) error {
	type Copy GetWasmBytecodeArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetWasmBytecodeArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetWasmBytecode in the Debugger domain.
func (a *GetWasmBytecodeArgs) MarshalJSON() ([]byte, error) {
	type Copy GetWasmBytecodeArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetWasmBytecodeReply represents the return values for GetWasmBytecode in the Debugger domain.
type GetWasmBytecodeReply struct {
	Bytecode string `json:"bytecode"` // Script source.
}

// GetWasmBytecodeReply returns whether or not the FrameID matches the reply value for GetWasmBytecode in the Debugger domain.
func (a *GetWasmBytecodeReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: GetWasmBytecodeReply %s", err)
		return false, err
	}
	return true, nil
}

// GetWasmBytecodeReply returns the FrameID value for GetWasmBytecode in the Debugger domain.
func (a *GetWasmBytecodeReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for GetWasmBytecode in the Debugger domain.
func (a *GetWasmBytecodeReply) UnmarshalJSON(b []byte) error {
	type Copy GetWasmBytecodeReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetWasmBytecodeReply(*c)
	return nil
}

// GetStackTraceArgs represents the arguments for GetStackTrace in the Debugger domain.
type GetStackTraceArgs struct {
	StackTraceID runtime.StackTraceID `json:"stackTraceId"` // No description.
}

// Unmarshal the byte array into a return value for GetStackTrace in the Debugger domain.
func (a *GetStackTraceArgs) UnmarshalJSON(b []byte) error {
	type Copy GetStackTraceArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetStackTraceArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetStackTrace in the Debugger domain.
func (a *GetStackTraceArgs) MarshalJSON() ([]byte, error) {
	type Copy GetStackTraceArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetStackTraceReply represents the return values for GetStackTrace in the Debugger domain.
type GetStackTraceReply struct {
	StackTrace runtime.StackTrace `json:"stackTrace"` // No description.
}

// GetStackTraceReply returns whether or not the FrameID matches the reply value for GetStackTrace in the Debugger domain.
func (a *GetStackTraceReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: GetStackTraceReply %s", err)
		return false, err
	}
	return true, nil
}

// GetStackTraceReply returns the FrameID value for GetStackTrace in the Debugger domain.
func (a *GetStackTraceReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for GetStackTrace in the Debugger domain.
func (a *GetStackTraceReply) UnmarshalJSON(b []byte) error {
	type Copy GetStackTraceReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetStackTraceReply(*c)
	return nil
}

// PauseArgs represents the arguments for Pause in the Debugger domain.
type PauseArgs struct {
}

// Unmarshal the byte array into a return value for Pause in the Debugger domain.
func (a *PauseArgs) UnmarshalJSON(b []byte) error {
	type Copy PauseArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = PauseArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Pause in the Debugger domain.
func (a *PauseArgs) MarshalJSON() ([]byte, error) {
	type Copy PauseArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// PauseReply represents the return values for Pause in the Debugger domain.
type PauseReply struct {
}

// PauseReply returns whether or not the FrameID matches the reply value for Pause in the Debugger domain.
func (a *PauseReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: PauseReply %s", err)
		return false, err
	}
	return true, nil
}

// PauseReply returns the FrameID value for Pause in the Debugger domain.
func (a *PauseReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for Pause in the Debugger domain.
func (a *PauseReply) UnmarshalJSON(b []byte) error {
	type Copy PauseReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = PauseReply(*c)
	return nil
}

// PauseOnAsyncCallArgs represents the arguments for PauseOnAsyncCall in the Debugger domain.
type PauseOnAsyncCallArgs struct {
	ParentStackTraceID runtime.StackTraceID `json:"parentStackTraceId"` // Debugger will pause when async call with given stack trace is started.
}

// Unmarshal the byte array into a return value for PauseOnAsyncCall in the Debugger domain.
func (a *PauseOnAsyncCallArgs) UnmarshalJSON(b []byte) error {
	type Copy PauseOnAsyncCallArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = PauseOnAsyncCallArgs(*c)
	return nil
}

// Marshall the byte array into a return value for PauseOnAsyncCall in the Debugger domain.
func (a *PauseOnAsyncCallArgs) MarshalJSON() ([]byte, error) {
	type Copy PauseOnAsyncCallArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// PauseOnAsyncCallReply represents the return values for PauseOnAsyncCall in the Debugger domain.
type PauseOnAsyncCallReply struct {
}

// PauseOnAsyncCallReply returns whether or not the FrameID matches the reply value for PauseOnAsyncCall in the Debugger domain.
func (a *PauseOnAsyncCallReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: PauseOnAsyncCallReply %s", err)
		return false, err
	}
	return true, nil
}

// PauseOnAsyncCallReply returns the FrameID value for PauseOnAsyncCall in the Debugger domain.
func (a *PauseOnAsyncCallReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for PauseOnAsyncCall in the Debugger domain.
func (a *PauseOnAsyncCallReply) UnmarshalJSON(b []byte) error {
	type Copy PauseOnAsyncCallReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = PauseOnAsyncCallReply(*c)
	return nil
}

// RemoveBreakpointArgs represents the arguments for RemoveBreakpoint in the Debugger domain.
type RemoveBreakpointArgs struct {
	BreakpointID BreakpointID `json:"breakpointId"` // No description.
}

// Unmarshal the byte array into a return value for RemoveBreakpoint in the Debugger domain.
func (a *RemoveBreakpointArgs) UnmarshalJSON(b []byte) error {
	type Copy RemoveBreakpointArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RemoveBreakpointArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RemoveBreakpoint in the Debugger domain.
func (a *RemoveBreakpointArgs) MarshalJSON() ([]byte, error) {
	type Copy RemoveBreakpointArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RemoveBreakpointReply represents the return values for RemoveBreakpoint in the Debugger domain.
type RemoveBreakpointReply struct {
}

// RemoveBreakpointReply returns whether or not the FrameID matches the reply value for RemoveBreakpoint in the Debugger domain.
func (a *RemoveBreakpointReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: RemoveBreakpointReply %s", err)
		return false, err
	}
	return true, nil
}

// RemoveBreakpointReply returns the FrameID value for RemoveBreakpoint in the Debugger domain.
func (a *RemoveBreakpointReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for RemoveBreakpoint in the Debugger domain.
func (a *RemoveBreakpointReply) UnmarshalJSON(b []byte) error {
	type Copy RemoveBreakpointReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RemoveBreakpointReply(*c)
	return nil
}

// RestartFrameArgs represents the arguments for RestartFrame in the Debugger domain.
type RestartFrameArgs struct {
	CallFrameID CallFrameID `json:"callFrameId"` // Call frame identifier to evaluate on.
}

// Unmarshal the byte array into a return value for RestartFrame in the Debugger domain.
func (a *RestartFrameArgs) UnmarshalJSON(b []byte) error {
	type Copy RestartFrameArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RestartFrameArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RestartFrame in the Debugger domain.
func (a *RestartFrameArgs) MarshalJSON() ([]byte, error) {
	type Copy RestartFrameArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RestartFrameReply represents the return values for RestartFrame in the Debugger domain.
type RestartFrameReply struct {
	CallFrames      []CallFrame         `json:"callFrames"`                // New stack trace.
	AsyncStackTrace *runtime.StackTrace `json:"asyncStackTrace,omitempty"` // Async stack trace, if any.
	// AsyncStackTraceID Async stack trace, if any.
	//
	// Note: This property is experimental.
	AsyncStackTraceID runtime.StackTraceID `json:"asyncStackTraceId,omitempty"`
}

// RestartFrameReply returns whether or not the FrameID matches the reply value for RestartFrame in the Debugger domain.
func (a *RestartFrameReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: RestartFrameReply %s", err)
		return false, err
	}
	return true, nil
}

// RestartFrameReply returns the FrameID value for RestartFrame in the Debugger domain.
func (a *RestartFrameReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for RestartFrame in the Debugger domain.
func (a *RestartFrameReply) UnmarshalJSON(b []byte) error {
	type Copy RestartFrameReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RestartFrameReply(*c)
	return nil
}

// ResumeArgs represents the arguments for Resume in the Debugger domain.
type ResumeArgs struct {
	TerminateOnResume bool `json:"terminateOnResume,omitempty"` // Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect.
}

// Unmarshal the byte array into a return value for Resume in the Debugger domain.
func (a *ResumeArgs) UnmarshalJSON(b []byte) error {
	type Copy ResumeArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ResumeArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Resume in the Debugger domain.
func (a *ResumeArgs) MarshalJSON() ([]byte, error) {
	type Copy ResumeArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ResumeReply represents the return values for Resume in the Debugger domain.
type ResumeReply struct {
}

// ResumeReply returns whether or not the FrameID matches the reply value for Resume in the Debugger domain.
func (a *ResumeReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: ResumeReply %s", err)
		return false, err
	}
	return true, nil
}

// ResumeReply returns the FrameID value for Resume in the Debugger domain.
func (a *ResumeReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for Resume in the Debugger domain.
func (a *ResumeReply) UnmarshalJSON(b []byte) error {
	type Copy ResumeReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ResumeReply(*c)
	return nil
}

// SearchInContentArgs represents the arguments for SearchInContent in the Debugger domain.
type SearchInContentArgs struct {
	ScriptID      runtime.ScriptID `json:"scriptId"`                // Id of the script to search in.
	Query         string           `json:"query"`                   // String to search for.
	CaseSensitive bool             `json:"caseSensitive,omitempty"` // If true, search is case sensitive.
	IsRegex       bool             `json:"isRegex,omitempty"`       // If true, treats string parameter as regex.
}

// Unmarshal the byte array into a return value for SearchInContent in the Debugger domain.
func (a *SearchInContentArgs) UnmarshalJSON(b []byte) error {
	type Copy SearchInContentArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SearchInContentArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SearchInContent in the Debugger domain.
func (a *SearchInContentArgs) MarshalJSON() ([]byte, error) {
	type Copy SearchInContentArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SearchInContentReply represents the return values for SearchInContent in the Debugger domain.
type SearchInContentReply struct {
	Result []SearchMatch `json:"result"` // List of search matches.
}

// SearchInContentReply returns whether or not the FrameID matches the reply value for SearchInContent in the Debugger domain.
func (a *SearchInContentReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SearchInContentReply %s", err)
		return false, err
	}
	return true, nil
}

// SearchInContentReply returns the FrameID value for SearchInContent in the Debugger domain.
func (a *SearchInContentReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SearchInContent in the Debugger domain.
func (a *SearchInContentReply) UnmarshalJSON(b []byte) error {
	type Copy SearchInContentReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SearchInContentReply(*c)
	return nil
}

// SetAsyncCallStackDepthArgs represents the arguments for SetAsyncCallStackDepth in the Debugger domain.
type SetAsyncCallStackDepthArgs struct {
	MaxDepth int `json:"maxDepth"` // Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async call stacks (default).
}

// Unmarshal the byte array into a return value for SetAsyncCallStackDepth in the Debugger domain.
func (a *SetAsyncCallStackDepthArgs) UnmarshalJSON(b []byte) error {
	type Copy SetAsyncCallStackDepthArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetAsyncCallStackDepthArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetAsyncCallStackDepth in the Debugger domain.
func (a *SetAsyncCallStackDepthArgs) MarshalJSON() ([]byte, error) {
	type Copy SetAsyncCallStackDepthArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetAsyncCallStackDepthReply represents the return values for SetAsyncCallStackDepth in the Debugger domain.
type SetAsyncCallStackDepthReply struct {
}

// SetAsyncCallStackDepthReply returns whether or not the FrameID matches the reply value for SetAsyncCallStackDepth in the Debugger domain.
func (a *SetAsyncCallStackDepthReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetAsyncCallStackDepthReply %s", err)
		return false, err
	}
	return true, nil
}

// SetAsyncCallStackDepthReply returns the FrameID value for SetAsyncCallStackDepth in the Debugger domain.
func (a *SetAsyncCallStackDepthReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetAsyncCallStackDepth in the Debugger domain.
func (a *SetAsyncCallStackDepthReply) UnmarshalJSON(b []byte) error {
	type Copy SetAsyncCallStackDepthReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetAsyncCallStackDepthReply(*c)
	return nil
}

// SetBlackboxPatternsArgs represents the arguments for SetBlackboxPatterns in the Debugger domain.
type SetBlackboxPatternsArgs struct {
	Patterns []string `json:"patterns"` // Array of regexps that will be used to check script url for blackbox state.
}

// Unmarshal the byte array into a return value for SetBlackboxPatterns in the Debugger domain.
func (a *SetBlackboxPatternsArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBlackboxPatternsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBlackboxPatternsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBlackboxPatterns in the Debugger domain.
func (a *SetBlackboxPatternsArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBlackboxPatternsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBlackboxPatternsReply represents the return values for SetBlackboxPatterns in the Debugger domain.
type SetBlackboxPatternsReply struct {
}

// SetBlackboxPatternsReply returns whether or not the FrameID matches the reply value for SetBlackboxPatterns in the Debugger domain.
func (a *SetBlackboxPatternsReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetBlackboxPatternsReply %s", err)
		return false, err
	}
	return true, nil
}

// SetBlackboxPatternsReply returns the FrameID value for SetBlackboxPatterns in the Debugger domain.
func (a *SetBlackboxPatternsReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetBlackboxPatterns in the Debugger domain.
func (a *SetBlackboxPatternsReply) UnmarshalJSON(b []byte) error {
	type Copy SetBlackboxPatternsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBlackboxPatternsReply(*c)
	return nil
}

// SetBlackboxedRangesArgs represents the arguments for SetBlackboxedRanges in the Debugger domain.
type SetBlackboxedRangesArgs struct {
	ScriptID  runtime.ScriptID `json:"scriptId"`  // Id of the script.
	Positions []ScriptPosition `json:"positions"` // No description.
}

// Unmarshal the byte array into a return value for SetBlackboxedRanges in the Debugger domain.
func (a *SetBlackboxedRangesArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBlackboxedRangesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBlackboxedRangesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBlackboxedRanges in the Debugger domain.
func (a *SetBlackboxedRangesArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBlackboxedRangesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBlackboxedRangesReply represents the return values for SetBlackboxedRanges in the Debugger domain.
type SetBlackboxedRangesReply struct {
}

// SetBlackboxedRangesReply returns whether or not the FrameID matches the reply value for SetBlackboxedRanges in the Debugger domain.
func (a *SetBlackboxedRangesReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetBlackboxedRangesReply %s", err)
		return false, err
	}
	return true, nil
}

// SetBlackboxedRangesReply returns the FrameID value for SetBlackboxedRanges in the Debugger domain.
func (a *SetBlackboxedRangesReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetBlackboxedRanges in the Debugger domain.
func (a *SetBlackboxedRangesReply) UnmarshalJSON(b []byte) error {
	type Copy SetBlackboxedRangesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBlackboxedRangesReply(*c)
	return nil
}

// SetBreakpointArgs represents the arguments for SetBreakpoint in the Debugger domain.
type SetBreakpointArgs struct {
	Location  Location `json:"location"`            // Location to set breakpoint in.
	Condition string   `json:"condition,omitempty"` // Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
}

// Unmarshal the byte array into a return value for SetBreakpoint in the Debugger domain.
func (a *SetBreakpointArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBreakpoint in the Debugger domain.
func (a *SetBreakpointArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBreakpointArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBreakpointReply represents the return values for SetBreakpoint in the Debugger domain.
type SetBreakpointReply struct {
	BreakpointID   BreakpointID `json:"breakpointId"`   // Id of the created breakpoint for further reference.
	ActualLocation Location     `json:"actualLocation"` // Location this breakpoint resolved into.
}

// SetBreakpointReply returns whether or not the FrameID matches the reply value for SetBreakpoint in the Debugger domain.
func (a *SetBreakpointReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetBreakpointReply %s", err)
		return false, err
	}
	return true, nil
}

// SetBreakpointReply returns the FrameID value for SetBreakpoint in the Debugger domain.
func (a *SetBreakpointReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetBreakpoint in the Debugger domain.
func (a *SetBreakpointReply) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointReply(*c)
	return nil
}

// SetInstrumentationBreakpointArgs represents the arguments for SetInstrumentationBreakpoint in the Debugger domain.
type SetInstrumentationBreakpointArgs struct {
	// Instrumentation Instrumentation name.
	//
	// Values: "beforeScriptExecution", "beforeScriptWithSourceMapExecution".
	Instrumentation string `json:"instrumentation"`
}

// Unmarshal the byte array into a return value for SetInstrumentationBreakpoint in the Debugger domain.
func (a *SetInstrumentationBreakpointArgs) UnmarshalJSON(b []byte) error {
	type Copy SetInstrumentationBreakpointArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetInstrumentationBreakpointArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetInstrumentationBreakpoint in the Debugger domain.
func (a *SetInstrumentationBreakpointArgs) MarshalJSON() ([]byte, error) {
	type Copy SetInstrumentationBreakpointArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetInstrumentationBreakpointReply represents the return values for SetInstrumentationBreakpoint in the Debugger domain.
type SetInstrumentationBreakpointReply struct {
	BreakpointID BreakpointID `json:"breakpointId"` // Id of the created breakpoint for further reference.
}

// SetInstrumentationBreakpointReply returns whether or not the FrameID matches the reply value for SetInstrumentationBreakpoint in the Debugger domain.
func (a *SetInstrumentationBreakpointReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetInstrumentationBreakpointReply %s", err)
		return false, err
	}
	return true, nil
}

// SetInstrumentationBreakpointReply returns the FrameID value for SetInstrumentationBreakpoint in the Debugger domain.
func (a *SetInstrumentationBreakpointReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetInstrumentationBreakpoint in the Debugger domain.
func (a *SetInstrumentationBreakpointReply) UnmarshalJSON(b []byte) error {
	type Copy SetInstrumentationBreakpointReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetInstrumentationBreakpointReply(*c)
	return nil
}

// SetBreakpointByURLArgs represents the arguments for SetBreakpointByURL in the Debugger domain.
type SetBreakpointByURLArgs struct {
	LineNumber   int    `json:"lineNumber"`             // Line number to set breakpoint at.
	URL          string `json:"url,omitempty"`          // URL of the resources to set breakpoint on.
	URLRegex     string `json:"urlRegex,omitempty"`     // Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or `urlRegex` must be specified.
	ScriptHash   string `json:"scriptHash,omitempty"`   // Script hash of the resources to set breakpoint on.
	ColumnNumber int    `json:"columnNumber,omitempty"` // Offset in the line to set breakpoint at.
	Condition    string `json:"condition,omitempty"`    // Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
}

// Unmarshal the byte array into a return value for SetBreakpointByURL in the Debugger domain.
func (a *SetBreakpointByURLArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointByURLArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointByURLArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBreakpointByURL in the Debugger domain.
func (a *SetBreakpointByURLArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBreakpointByURLArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBreakpointByURLReply represents the return values for SetBreakpointByURL in the Debugger domain.
type SetBreakpointByURLReply struct {
	BreakpointID BreakpointID `json:"breakpointId"` // Id of the created breakpoint for further reference.
	Locations    []Location   `json:"locations"`    // List of the locations this breakpoint resolved into upon addition.
}

// SetBreakpointByURLReply returns whether or not the FrameID matches the reply value for SetBreakpointByURL in the Debugger domain.
func (a *SetBreakpointByURLReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetBreakpointByURLReply %s", err)
		return false, err
	}
	return true, nil
}

// SetBreakpointByURLReply returns the FrameID value for SetBreakpointByURL in the Debugger domain.
func (a *SetBreakpointByURLReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetBreakpointByURL in the Debugger domain.
func (a *SetBreakpointByURLReply) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointByURLReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointByURLReply(*c)
	return nil
}

// SetBreakpointOnFunctionCallArgs represents the arguments for SetBreakpointOnFunctionCall in the Debugger domain.
type SetBreakpointOnFunctionCallArgs struct {
	ObjectID  shared.RemoteObjectID `json:"objectId"`            // Function object id.
	Condition string                `json:"condition,omitempty"` // Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true.
}

// Unmarshal the byte array into a return value for SetBreakpointOnFunctionCall in the Debugger domain.
func (a *SetBreakpointOnFunctionCallArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointOnFunctionCallArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointOnFunctionCallArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBreakpointOnFunctionCall in the Debugger domain.
func (a *SetBreakpointOnFunctionCallArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBreakpointOnFunctionCallArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBreakpointOnFunctionCallReply represents the return values for SetBreakpointOnFunctionCall in the Debugger domain.
type SetBreakpointOnFunctionCallReply struct {
	BreakpointID BreakpointID `json:"breakpointId"` // Id of the created breakpoint for further reference.
}

// SetBreakpointOnFunctionCallReply returns whether or not the FrameID matches the reply value for SetBreakpointOnFunctionCall in the Debugger domain.
func (a *SetBreakpointOnFunctionCallReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetBreakpointOnFunctionCallReply %s", err)
		return false, err
	}
	return true, nil
}

// SetBreakpointOnFunctionCallReply returns the FrameID value for SetBreakpointOnFunctionCall in the Debugger domain.
func (a *SetBreakpointOnFunctionCallReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetBreakpointOnFunctionCall in the Debugger domain.
func (a *SetBreakpointOnFunctionCallReply) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointOnFunctionCallReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointOnFunctionCallReply(*c)
	return nil
}

// SetBreakpointsActiveArgs represents the arguments for SetBreakpointsActive in the Debugger domain.
type SetBreakpointsActiveArgs struct {
	Active bool `json:"active"` // New value for breakpoints active state.
}

// Unmarshal the byte array into a return value for SetBreakpointsActive in the Debugger domain.
func (a *SetBreakpointsActiveArgs) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointsActiveArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointsActiveArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetBreakpointsActive in the Debugger domain.
func (a *SetBreakpointsActiveArgs) MarshalJSON() ([]byte, error) {
	type Copy SetBreakpointsActiveArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetBreakpointsActiveReply represents the return values for SetBreakpointsActive in the Debugger domain.
type SetBreakpointsActiveReply struct {
}

// SetBreakpointsActiveReply returns whether or not the FrameID matches the reply value for SetBreakpointsActive in the Debugger domain.
func (a *SetBreakpointsActiveReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetBreakpointsActiveReply %s", err)
		return false, err
	}
	return true, nil
}

// SetBreakpointsActiveReply returns the FrameID value for SetBreakpointsActive in the Debugger domain.
func (a *SetBreakpointsActiveReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetBreakpointsActive in the Debugger domain.
func (a *SetBreakpointsActiveReply) UnmarshalJSON(b []byte) error {
	type Copy SetBreakpointsActiveReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetBreakpointsActiveReply(*c)
	return nil
}

// SetPauseOnExceptionsArgs represents the arguments for SetPauseOnExceptions in the Debugger domain.
type SetPauseOnExceptionsArgs struct {
	// State Pause on exceptions mode.
	//
	// Values: "none", "uncaught", "all".
	State string `json:"state"`
}

// Unmarshal the byte array into a return value for SetPauseOnExceptions in the Debugger domain.
func (a *SetPauseOnExceptionsArgs) UnmarshalJSON(b []byte) error {
	type Copy SetPauseOnExceptionsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetPauseOnExceptionsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetPauseOnExceptions in the Debugger domain.
func (a *SetPauseOnExceptionsArgs) MarshalJSON() ([]byte, error) {
	type Copy SetPauseOnExceptionsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetPauseOnExceptionsReply represents the return values for SetPauseOnExceptions in the Debugger domain.
type SetPauseOnExceptionsReply struct {
}

// SetPauseOnExceptionsReply returns whether or not the FrameID matches the reply value for SetPauseOnExceptions in the Debugger domain.
func (a *SetPauseOnExceptionsReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetPauseOnExceptionsReply %s", err)
		return false, err
	}
	return true, nil
}

// SetPauseOnExceptionsReply returns the FrameID value for SetPauseOnExceptions in the Debugger domain.
func (a *SetPauseOnExceptionsReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetPauseOnExceptions in the Debugger domain.
func (a *SetPauseOnExceptionsReply) UnmarshalJSON(b []byte) error {
	type Copy SetPauseOnExceptionsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetPauseOnExceptionsReply(*c)
	return nil
}

// SetReturnValueArgs represents the arguments for SetReturnValue in the Debugger domain.
type SetReturnValueArgs struct {
	NewValue runtime.CallArgument `json:"newValue"` // New return value.
}

// Unmarshal the byte array into a return value for SetReturnValue in the Debugger domain.
func (a *SetReturnValueArgs) UnmarshalJSON(b []byte) error {
	type Copy SetReturnValueArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetReturnValueArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetReturnValue in the Debugger domain.
func (a *SetReturnValueArgs) MarshalJSON() ([]byte, error) {
	type Copy SetReturnValueArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetReturnValueReply represents the return values for SetReturnValue in the Debugger domain.
type SetReturnValueReply struct {
}

// SetReturnValueReply returns whether or not the FrameID matches the reply value for SetReturnValue in the Debugger domain.
func (a *SetReturnValueReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetReturnValueReply %s", err)
		return false, err
	}
	return true, nil
}

// SetReturnValueReply returns the FrameID value for SetReturnValue in the Debugger domain.
func (a *SetReturnValueReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetReturnValue in the Debugger domain.
func (a *SetReturnValueReply) UnmarshalJSON(b []byte) error {
	type Copy SetReturnValueReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetReturnValueReply(*c)
	return nil
}

// SetScriptSourceArgs represents the arguments for SetScriptSource in the Debugger domain.
type SetScriptSourceArgs struct {
	ScriptID     runtime.ScriptID `json:"scriptId"`         // Id of the script to edit.
	ScriptSource string           `json:"scriptSource"`     // New content of the script.
	DryRun       bool             `json:"dryRun,omitempty"` // If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
}

// Unmarshal the byte array into a return value for SetScriptSource in the Debugger domain.
func (a *SetScriptSourceArgs) UnmarshalJSON(b []byte) error {
	type Copy SetScriptSourceArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetScriptSourceArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetScriptSource in the Debugger domain.
func (a *SetScriptSourceArgs) MarshalJSON() ([]byte, error) {
	type Copy SetScriptSourceArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetScriptSourceReply represents the return values for SetScriptSource in the Debugger domain.
type SetScriptSourceReply struct {
	CallFrames      *[]CallFrame        `json:"callFrames,omitempty"`      // New stack trace in case editing has happened while VM was stopped.
	StackChanged    bool                `json:"stackChanged,omitempty"`    // Whether current call stack was modified after applying the changes.
	AsyncStackTrace *runtime.StackTrace `json:"asyncStackTrace,omitempty"` // Async stack trace, if any.
	// AsyncStackTraceID Async stack trace, if any.
	//
	// Note: This property is experimental.
	AsyncStackTraceID runtime.StackTraceID      `json:"asyncStackTraceId,omitempty"`
	ExceptionDetails  *runtime.ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details if any.
}

// SetScriptSourceReply returns whether or not the FrameID matches the reply value for SetScriptSource in the Debugger domain.
func (a *SetScriptSourceReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetScriptSourceReply %s", err)
		return false, err
	}
	return true, nil
}

// SetScriptSourceReply returns the FrameID value for SetScriptSource in the Debugger domain.
func (a *SetScriptSourceReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetScriptSource in the Debugger domain.
func (a *SetScriptSourceReply) UnmarshalJSON(b []byte) error {
	type Copy SetScriptSourceReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetScriptSourceReply(*c)
	return nil
}

// SetSkipAllPausesArgs represents the arguments for SetSkipAllPauses in the Debugger domain.
type SetSkipAllPausesArgs struct {
	Skip bool `json:"skip"` // New value for skip pauses state.
}

// Unmarshal the byte array into a return value for SetSkipAllPauses in the Debugger domain.
func (a *SetSkipAllPausesArgs) UnmarshalJSON(b []byte) error {
	type Copy SetSkipAllPausesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetSkipAllPausesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetSkipAllPauses in the Debugger domain.
func (a *SetSkipAllPausesArgs) MarshalJSON() ([]byte, error) {
	type Copy SetSkipAllPausesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetSkipAllPausesReply represents the return values for SetSkipAllPauses in the Debugger domain.
type SetSkipAllPausesReply struct {
}

// SetSkipAllPausesReply returns whether or not the FrameID matches the reply value for SetSkipAllPauses in the Debugger domain.
func (a *SetSkipAllPausesReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetSkipAllPausesReply %s", err)
		return false, err
	}
	return true, nil
}

// SetSkipAllPausesReply returns the FrameID value for SetSkipAllPauses in the Debugger domain.
func (a *SetSkipAllPausesReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetSkipAllPauses in the Debugger domain.
func (a *SetSkipAllPausesReply) UnmarshalJSON(b []byte) error {
	type Copy SetSkipAllPausesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetSkipAllPausesReply(*c)
	return nil
}

// SetVariableValueArgs represents the arguments for SetVariableValue in the Debugger domain.
type SetVariableValueArgs struct {
	ScopeNumber  int                  `json:"scopeNumber"`  // 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
	VariableName string               `json:"variableName"` // Variable name.
	NewValue     runtime.CallArgument `json:"newValue"`     // New variable value.
	CallFrameID  CallFrameID          `json:"callFrameId"`  // Id of callframe that holds variable.
}

// Unmarshal the byte array into a return value for SetVariableValue in the Debugger domain.
func (a *SetVariableValueArgs) UnmarshalJSON(b []byte) error {
	type Copy SetVariableValueArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetVariableValueArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetVariableValue in the Debugger domain.
func (a *SetVariableValueArgs) MarshalJSON() ([]byte, error) {
	type Copy SetVariableValueArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetVariableValueReply represents the return values for SetVariableValue in the Debugger domain.
type SetVariableValueReply struct {
}

// SetVariableValueReply returns whether or not the FrameID matches the reply value for SetVariableValue in the Debugger domain.
func (a *SetVariableValueReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: SetVariableValueReply %s", err)
		return false, err
	}
	return true, nil
}

// SetVariableValueReply returns the FrameID value for SetVariableValue in the Debugger domain.
func (a *SetVariableValueReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for SetVariableValue in the Debugger domain.
func (a *SetVariableValueReply) UnmarshalJSON(b []byte) error {
	type Copy SetVariableValueReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetVariableValueReply(*c)
	return nil
}

// StepIntoArgs represents the arguments for StepInto in the Debugger domain.
type StepIntoArgs struct {
	// BreakOnAsyncCall Debugger will pause on the execution of the first
	// async task which was scheduled before next pause.
	//
	// Note: This property is experimental.
	BreakOnAsyncCall bool `json:"breakOnAsyncCall,omitempty"`
}

// Unmarshal the byte array into a return value for StepInto in the Debugger domain.
func (a *StepIntoArgs) UnmarshalJSON(b []byte) error {
	type Copy StepIntoArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StepIntoArgs(*c)
	return nil
}

// Marshall the byte array into a return value for StepInto in the Debugger domain.
func (a *StepIntoArgs) MarshalJSON() ([]byte, error) {
	type Copy StepIntoArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// StepIntoReply represents the return values for StepInto in the Debugger domain.
type StepIntoReply struct {
}

// StepIntoReply returns whether or not the FrameID matches the reply value for StepInto in the Debugger domain.
func (a *StepIntoReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: StepIntoReply %s", err)
		return false, err
	}
	return true, nil
}

// StepIntoReply returns the FrameID value for StepInto in the Debugger domain.
func (a *StepIntoReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for StepInto in the Debugger domain.
func (a *StepIntoReply) UnmarshalJSON(b []byte) error {
	type Copy StepIntoReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StepIntoReply(*c)
	return nil
}

// StepOutArgs represents the arguments for StepOut in the Debugger domain.
type StepOutArgs struct {
}

// Unmarshal the byte array into a return value for StepOut in the Debugger domain.
func (a *StepOutArgs) UnmarshalJSON(b []byte) error {
	type Copy StepOutArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StepOutArgs(*c)
	return nil
}

// Marshall the byte array into a return value for StepOut in the Debugger domain.
func (a *StepOutArgs) MarshalJSON() ([]byte, error) {
	type Copy StepOutArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// StepOutReply represents the return values for StepOut in the Debugger domain.
type StepOutReply struct {
}

// StepOutReply returns whether or not the FrameID matches the reply value for StepOut in the Debugger domain.
func (a *StepOutReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: StepOutReply %s", err)
		return false, err
	}
	return true, nil
}

// StepOutReply returns the FrameID value for StepOut in the Debugger domain.
func (a *StepOutReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for StepOut in the Debugger domain.
func (a *StepOutReply) UnmarshalJSON(b []byte) error {
	type Copy StepOutReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StepOutReply(*c)
	return nil
}

// StepOverArgs represents the arguments for StepOver in the Debugger domain.
type StepOverArgs struct {
}

// Unmarshal the byte array into a return value for StepOver in the Debugger domain.
func (a *StepOverArgs) UnmarshalJSON(b []byte) error {
	type Copy StepOverArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StepOverArgs(*c)
	return nil
}

// Marshall the byte array into a return value for StepOver in the Debugger domain.
func (a *StepOverArgs) MarshalJSON() ([]byte, error) {
	type Copy StepOverArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// StepOverReply represents the return values for StepOver in the Debugger domain.
type StepOverReply struct {
}

// StepOverReply returns whether or not the FrameID matches the reply value for StepOver in the Debugger domain.
func (a *StepOverReply) MatchFrameID(frameID string, m []byte) (bool, error) {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Printf("unmarshal error: StepOverReply %s", err)
		return false, err
	}
	return true, nil
}

// StepOverReply returns the FrameID value for StepOver in the Debugger domain.
func (a *StepOverReply) GetFrameID() string {
	return ""
}

// Unmarshal the byte array into a return value for StepOver in the Debugger domain.
func (a *StepOverReply) UnmarshalJSON(b []byte) error {
	type Copy StepOverReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = StepOverReply(*c)
	return nil
}
