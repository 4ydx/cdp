// Code generated by cdpgen. DO NOT EDIT.

package runtime

import (
	"encoding/json"
	"log"

	"github.com/4ydx/cdp/protocol"
)

const (
	CommandRuntimeAwaitPromise                    = "Runtime.awaitPromise"
	CommandRuntimeCallFunctionOn                  = "Runtime.callFunctionOn"
	CommandRuntimeCompileScript                   = "Runtime.compileScript"
	CommandRuntimeDisable                         = "Runtime.disable"
	CommandRuntimeDiscardConsoleEntries           = "Runtime.discardConsoleEntries"
	CommandRuntimeEnable                          = "Runtime.enable"
	CommandRuntimeEvaluate                        = "Runtime.evaluate"
	CommandRuntimeGetIsolateId                    = "Runtime.getIsolateId"
	CommandRuntimeGetHeapUsage                    = "Runtime.getHeapUsage"
	CommandRuntimeGetProperties                   = "Runtime.getProperties"
	CommandRuntimeGlobalLexicalScopeNames         = "Runtime.globalLexicalScopeNames"
	CommandRuntimeQueryObjects                    = "Runtime.queryObjects"
	CommandRuntimeReleaseObject                   = "Runtime.releaseObject"
	CommandRuntimeReleaseObjectGroup              = "Runtime.releaseObjectGroup"
	CommandRuntimeRunIfWaitingForDebugger         = "Runtime.runIfWaitingForDebugger"
	CommandRuntimeRunScript                       = "Runtime.runScript"
	CommandRuntimeSetAsyncCallStackDepth          = "Runtime.setAsyncCallStackDepth"
	CommandRuntimeSetCustomObjectFormatterEnabled = "Runtime.setCustomObjectFormatterEnabled"
	CommandRuntimeSetMaxCallStackSizeToCapture    = "Runtime.setMaxCallStackSizeToCapture"
	CommandRuntimeTerminateExecution              = "Runtime.terminateExecution"
	CommandRuntimeAddBinding                      = "Runtime.addBinding"
	CommandRuntimeRemoveBinding                   = "Runtime.removeBinding"
)

// AwaitPromiseArgs represents the arguments for AwaitPromise in the Runtime domain.
type AwaitPromiseArgs struct {
	PromiseObjectID shared.RemoteObjectID `json:"promiseObjectId"`           // Identifier of the promise.
	ReturnByValue   bool                  `json:"returnByValue,omitempty"`   // Whether the result is expected to be a JSON object that should be sent by value.
	GeneratePreview bool                  `json:"generatePreview,omitempty"` // Whether preview should be generated for the result.
}

// Unmarshal the byte array into a return value for AwaitPromise in the Runtime domain.
func (a *AwaitPromiseArgs) UnmarshalJSON(b []byte) error {
	type Copy AwaitPromiseArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = AwaitPromiseArgs(*c)
	return nil
}

// Marshall the byte array into a return value for AwaitPromise in the Runtime domain.
func (a *AwaitPromiseArgs) MarshalJSON() ([]byte, error) {
	type Copy AwaitPromiseArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// AwaitPromiseReply represents the return values for AwaitPromise in the Runtime domain.
type AwaitPromiseReply struct {
	Result           RemoteObject     `json:"result"`                     // Promise result. Will contain rejected value if promise was rejected.
	ExceptionDetails ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details if stack strace is available.
}

// AwaitPromiseReply returns whether or not the FrameID matches the reply value for AwaitPromise in the Runtime domain.
func (a *AwaitPromiseReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: AwaitPromiseReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for AwaitPromise in the Runtime domain.
func (a *AwaitPromiseReply) UnmarshalJSON(b []byte) error {
	type Copy AwaitPromiseReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = AwaitPromiseReply(*c)
	return nil
}

// CallFunctionOnArgs represents the arguments for CallFunctionOn in the Runtime domain.
type CallFunctionOnArgs struct {
	FunctionDeclaration string                `json:"functionDeclaration"`     // Declaration of the function to call.
	ObjectID            shared.RemoteObjectID `json:"objectId,omitempty"`      // Identifier of the object to call function on. Either objectId or executionContextId should be specified.
	Arguments           []CallArgument        `json:"arguments,omitempty"`     // Call arguments. All call arguments must belong to the same JavaScript world as the target object.
	Silent              bool                  `json:"silent,omitempty"`        // In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
	ReturnByValue       bool                  `json:"returnByValue,omitempty"` // Whether the result is expected to be a JSON object which should be sent by value.
	// GeneratePreview Whether preview should be generated for the result.
	//
	// Note: This property is experimental.
	GeneratePreview    bool               `json:"generatePreview,omitempty"`
	UserGesture        bool               `json:"userGesture,omitempty"`        // Whether execution should be treated as initiated by user in the UI.
	AwaitPromise       bool               `json:"awaitPromise,omitempty"`       // Whether execution should `await` for resulting value and return once awaited promise is resolved.
	ExecutionContextID ExecutionContextID `json:"executionContextId,omitempty"` // Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
	ObjectGroup        string             `json:"objectGroup,omitempty"`        // Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
}

// Unmarshal the byte array into a return value for CallFunctionOn in the Runtime domain.
func (a *CallFunctionOnArgs) UnmarshalJSON(b []byte) error {
	type Copy CallFunctionOnArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CallFunctionOnArgs(*c)
	return nil
}

// Marshall the byte array into a return value for CallFunctionOn in the Runtime domain.
func (a *CallFunctionOnArgs) MarshalJSON() ([]byte, error) {
	type Copy CallFunctionOnArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// CallFunctionOnReply represents the return values for CallFunctionOn in the Runtime domain.
type CallFunctionOnReply struct {
	Result           RemoteObject     `json:"result"`                     // Call result.
	ExceptionDetails ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details.
}

// CallFunctionOnReply returns whether or not the FrameID matches the reply value for CallFunctionOn in the Runtime domain.
func (a *CallFunctionOnReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: CallFunctionOnReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for CallFunctionOn in the Runtime domain.
func (a *CallFunctionOnReply) UnmarshalJSON(b []byte) error {
	type Copy CallFunctionOnReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CallFunctionOnReply(*c)
	return nil
}

// CompileScriptArgs represents the arguments for CompileScript in the Runtime domain.
type CompileScriptArgs struct {
	Expression         string             `json:"expression"`                   // Expression to compile.
	SourceURL          string             `json:"sourceURL"`                    // Source url to be set for the script.
	PersistScript      bool               `json:"persistScript"`                // Specifies whether the compiled script should be persisted.
	ExecutionContextID ExecutionContextID `json:"executionContextId,omitempty"` // Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
}

// Unmarshal the byte array into a return value for CompileScript in the Runtime domain.
func (a *CompileScriptArgs) UnmarshalJSON(b []byte) error {
	type Copy CompileScriptArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CompileScriptArgs(*c)
	return nil
}

// Marshall the byte array into a return value for CompileScript in the Runtime domain.
func (a *CompileScriptArgs) MarshalJSON() ([]byte, error) {
	type Copy CompileScriptArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// CompileScriptReply represents the return values for CompileScript in the Runtime domain.
type CompileScriptReply struct {
	ScriptID         ScriptID         `json:"scriptId,omitempty"`         // Id of the script.
	ExceptionDetails ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details.
}

// CompileScriptReply returns whether or not the FrameID matches the reply value for CompileScript in the Runtime domain.
func (a *CompileScriptReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: CompileScriptReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for CompileScript in the Runtime domain.
func (a *CompileScriptReply) UnmarshalJSON(b []byte) error {
	type Copy CompileScriptReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = CompileScriptReply(*c)
	return nil
}

// DisableArgs represents the arguments for Disable in the Runtime domain.
type DisableArgs struct {
}

// Unmarshal the byte array into a return value for Disable in the Runtime domain.
func (a *DisableArgs) UnmarshalJSON(b []byte) error {
	type Copy DisableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Disable in the Runtime domain.
func (a *DisableArgs) MarshalJSON() ([]byte, error) {
	type Copy DisableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// DisableReply represents the return values for Disable in the Runtime domain.
type DisableReply struct {
}

// DisableReply returns whether or not the FrameID matches the reply value for Disable in the Runtime domain.
func (a *DisableReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: DisableReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for Disable in the Runtime domain.
func (a *DisableReply) UnmarshalJSON(b []byte) error {
	type Copy DisableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DisableReply(*c)
	return nil
}

// DiscardConsoleEntriesArgs represents the arguments for DiscardConsoleEntries in the Runtime domain.
type DiscardConsoleEntriesArgs struct {
}

// Unmarshal the byte array into a return value for DiscardConsoleEntries in the Runtime domain.
func (a *DiscardConsoleEntriesArgs) UnmarshalJSON(b []byte) error {
	type Copy DiscardConsoleEntriesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DiscardConsoleEntriesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for DiscardConsoleEntries in the Runtime domain.
func (a *DiscardConsoleEntriesArgs) MarshalJSON() ([]byte, error) {
	type Copy DiscardConsoleEntriesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// DiscardConsoleEntriesReply represents the return values for DiscardConsoleEntries in the Runtime domain.
type DiscardConsoleEntriesReply struct {
}

// DiscardConsoleEntriesReply returns whether or not the FrameID matches the reply value for DiscardConsoleEntries in the Runtime domain.
func (a *DiscardConsoleEntriesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: DiscardConsoleEntriesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for DiscardConsoleEntries in the Runtime domain.
func (a *DiscardConsoleEntriesReply) UnmarshalJSON(b []byte) error {
	type Copy DiscardConsoleEntriesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = DiscardConsoleEntriesReply(*c)
	return nil
}

// EnableArgs represents the arguments for Enable in the Runtime domain.
type EnableArgs struct {
}

// Unmarshal the byte array into a return value for Enable in the Runtime domain.
func (a *EnableArgs) UnmarshalJSON(b []byte) error {
	type Copy EnableArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Enable in the Runtime domain.
func (a *EnableArgs) MarshalJSON() ([]byte, error) {
	type Copy EnableArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EnableReply represents the return values for Enable in the Runtime domain.
type EnableReply struct {
}

// EnableReply returns whether or not the FrameID matches the reply value for Enable in the Runtime domain.
func (a *EnableReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: EnableReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for Enable in the Runtime domain.
func (a *EnableReply) UnmarshalJSON(b []byte) error {
	type Copy EnableReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EnableReply(*c)
	return nil
}

// EvaluateArgs represents the arguments for Evaluate in the Runtime domain.
type EvaluateArgs struct {
	Expression            string             `json:"expression"`                      // Expression to evaluate.
	ObjectGroup           string             `json:"objectGroup,omitempty"`           // Symbolic group name that can be used to release multiple objects.
	IncludeCommandLineAPI bool               `json:"includeCommandLineAPI,omitempty"` // Determines whether Command Line API should be available during the evaluation.
	Silent                bool               `json:"silent,omitempty"`                // In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
	ContextID             ExecutionContextID `json:"contextId,omitempty"`             // Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
	ReturnByValue         bool               `json:"returnByValue,omitempty"`         // Whether the result is expected to be a JSON object that should be sent by value.
	// GeneratePreview Whether preview should be generated for the result.
	//
	// Note: This property is experimental.
	GeneratePreview bool `json:"generatePreview,omitempty"`
	UserGesture     bool `json:"userGesture,omitempty"`  // Whether execution should be treated as initiated by user in the UI.
	AwaitPromise    bool `json:"awaitPromise,omitempty"` // Whether execution should `await` for resulting value and return once awaited promise is resolved.
	// ThrowOnSideEffect Whether to throw an exception if side effect
	// cannot be ruled out during evaluation.
	//
	// Note: This property is experimental.
	ThrowOnSideEffect bool `json:"throwOnSideEffect,omitempty"`
	// Timeout Terminate execution after timing out (number of
	// milliseconds).
	//
	// Note: This property is experimental.
	Timeout TimeDelta `json:"timeout,omitempty"`
}

// Unmarshal the byte array into a return value for Evaluate in the Runtime domain.
func (a *EvaluateArgs) UnmarshalJSON(b []byte) error {
	type Copy EvaluateArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EvaluateArgs(*c)
	return nil
}

// Marshall the byte array into a return value for Evaluate in the Runtime domain.
func (a *EvaluateArgs) MarshalJSON() ([]byte, error) {
	type Copy EvaluateArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// EvaluateReply represents the return values for Evaluate in the Runtime domain.
type EvaluateReply struct {
	Result           RemoteObject     `json:"result"`                     // Evaluation result.
	ExceptionDetails ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details.
}

// EvaluateReply returns whether or not the FrameID matches the reply value for Evaluate in the Runtime domain.
func (a *EvaluateReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: EvaluateReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for Evaluate in the Runtime domain.
func (a *EvaluateReply) UnmarshalJSON(b []byte) error {
	type Copy EvaluateReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = EvaluateReply(*c)
	return nil
}

// GetIsolateIDArgs represents the arguments for GetIsolateID in the Runtime domain.
type GetIsolateIDArgs struct {
}

// Unmarshal the byte array into a return value for GetIsolateID in the Runtime domain.
func (a *GetIsolateIDArgs) UnmarshalJSON(b []byte) error {
	type Copy GetIsolateIDArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetIsolateIDArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetIsolateID in the Runtime domain.
func (a *GetIsolateIDArgs) MarshalJSON() ([]byte, error) {
	type Copy GetIsolateIDArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetIsolateIDReply represents the return values for GetIsolateID in the Runtime domain.
type GetIsolateIDReply struct {
	ID string `json:"id"` // The isolate id.
}

// GetIsolateIDReply returns whether or not the FrameID matches the reply value for GetIsolateID in the Runtime domain.
func (a *GetIsolateIDReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetIsolateIDReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetIsolateID in the Runtime domain.
func (a *GetIsolateIDReply) UnmarshalJSON(b []byte) error {
	type Copy GetIsolateIDReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetIsolateIDReply(*c)
	return nil
}

// GetHeapUsageArgs represents the arguments for GetHeapUsage in the Runtime domain.
type GetHeapUsageArgs struct {
}

// Unmarshal the byte array into a return value for GetHeapUsage in the Runtime domain.
func (a *GetHeapUsageArgs) UnmarshalJSON(b []byte) error {
	type Copy GetHeapUsageArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetHeapUsageArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetHeapUsage in the Runtime domain.
func (a *GetHeapUsageArgs) MarshalJSON() ([]byte, error) {
	type Copy GetHeapUsageArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetHeapUsageReply represents the return values for GetHeapUsage in the Runtime domain.
type GetHeapUsageReply struct {
	UsedSize  float64 `json:"usedSize"`  // Used heap size in bytes.
	TotalSize float64 `json:"totalSize"` // Allocated heap size in bytes.
}

// GetHeapUsageReply returns whether or not the FrameID matches the reply value for GetHeapUsage in the Runtime domain.
func (a *GetHeapUsageReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetHeapUsageReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetHeapUsage in the Runtime domain.
func (a *GetHeapUsageReply) UnmarshalJSON(b []byte) error {
	type Copy GetHeapUsageReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetHeapUsageReply(*c)
	return nil
}

// GetPropertiesArgs represents the arguments for GetProperties in the Runtime domain.
type GetPropertiesArgs struct {
	ObjectID      shared.RemoteObjectID `json:"objectId"`                // Identifier of the object to return properties for.
	OwnProperties bool                  `json:"ownProperties,omitempty"` // If true, returns properties belonging only to the element itself, not to its prototype chain.
	// AccessorPropertiesOnly If true, returns accessor properties (with
	// getter/setter) only; internal properties are not returned either.
	//
	// Note: This property is experimental.
	AccessorPropertiesOnly bool `json:"accessorPropertiesOnly,omitempty"`
	// GeneratePreview Whether preview should be generated for the
	// results.
	//
	// Note: This property is experimental.
	GeneratePreview bool `json:"generatePreview,omitempty"`
}

// Unmarshal the byte array into a return value for GetProperties in the Runtime domain.
func (a *GetPropertiesArgs) UnmarshalJSON(b []byte) error {
	type Copy GetPropertiesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetPropertiesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GetProperties in the Runtime domain.
func (a *GetPropertiesArgs) MarshalJSON() ([]byte, error) {
	type Copy GetPropertiesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GetPropertiesReply represents the return values for GetProperties in the Runtime domain.
type GetPropertiesReply struct {
	Result             []PropertyDescriptor         `json:"result"`                       // Object properties.
	InternalProperties []InternalPropertyDescriptor `json:"internalProperties,omitempty"` // Internal object properties (only of the element itself).
	ExceptionDetails   ExceptionDetails             `json:"exceptionDetails,omitempty"`   // Exception details.
}

// GetPropertiesReply returns whether or not the FrameID matches the reply value for GetProperties in the Runtime domain.
func (a *GetPropertiesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GetPropertiesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GetProperties in the Runtime domain.
func (a *GetPropertiesReply) UnmarshalJSON(b []byte) error {
	type Copy GetPropertiesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GetPropertiesReply(*c)
	return nil
}

// GlobalLexicalScopeNamesArgs represents the arguments for GlobalLexicalScopeNames in the Runtime domain.
type GlobalLexicalScopeNamesArgs struct {
	ExecutionContextID ExecutionContextID `json:"executionContextId,omitempty"` // Specifies in which execution context to lookup global scope variables.
}

// Unmarshal the byte array into a return value for GlobalLexicalScopeNames in the Runtime domain.
func (a *GlobalLexicalScopeNamesArgs) UnmarshalJSON(b []byte) error {
	type Copy GlobalLexicalScopeNamesArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GlobalLexicalScopeNamesArgs(*c)
	return nil
}

// Marshall the byte array into a return value for GlobalLexicalScopeNames in the Runtime domain.
func (a *GlobalLexicalScopeNamesArgs) MarshalJSON() ([]byte, error) {
	type Copy GlobalLexicalScopeNamesArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// GlobalLexicalScopeNamesReply represents the return values for GlobalLexicalScopeNames in the Runtime domain.
type GlobalLexicalScopeNamesReply struct {
	Names []string `json:"names"` // No description.
}

// GlobalLexicalScopeNamesReply returns whether or not the FrameID matches the reply value for GlobalLexicalScopeNames in the Runtime domain.
func (a *GlobalLexicalScopeNamesReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: GlobalLexicalScopeNamesReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for GlobalLexicalScopeNames in the Runtime domain.
func (a *GlobalLexicalScopeNamesReply) UnmarshalJSON(b []byte) error {
	type Copy GlobalLexicalScopeNamesReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = GlobalLexicalScopeNamesReply(*c)
	return nil
}

// QueryObjectsArgs represents the arguments for QueryObjects in the Runtime domain.
type QueryObjectsArgs struct {
	PrototypeObjectID shared.RemoteObjectID `json:"prototypeObjectId"`     // Identifier of the prototype to return objects for.
	ObjectGroup       string                `json:"objectGroup,omitempty"` // Symbolic group name that can be used to release the results.
}

// Unmarshal the byte array into a return value for QueryObjects in the Runtime domain.
func (a *QueryObjectsArgs) UnmarshalJSON(b []byte) error {
	type Copy QueryObjectsArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = QueryObjectsArgs(*c)
	return nil
}

// Marshall the byte array into a return value for QueryObjects in the Runtime domain.
func (a *QueryObjectsArgs) MarshalJSON() ([]byte, error) {
	type Copy QueryObjectsArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// QueryObjectsReply represents the return values for QueryObjects in the Runtime domain.
type QueryObjectsReply struct {
	Objects RemoteObject `json:"objects"` // Array with objects.
}

// QueryObjectsReply returns whether or not the FrameID matches the reply value for QueryObjects in the Runtime domain.
func (a *QueryObjectsReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: QueryObjectsReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for QueryObjects in the Runtime domain.
func (a *QueryObjectsReply) UnmarshalJSON(b []byte) error {
	type Copy QueryObjectsReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = QueryObjectsReply(*c)
	return nil
}

// ReleaseObjectArgs represents the arguments for ReleaseObject in the Runtime domain.
type ReleaseObjectArgs struct {
	ObjectID shared.RemoteObjectID `json:"objectId"` // Identifier of the object to release.
}

// Unmarshal the byte array into a return value for ReleaseObject in the Runtime domain.
func (a *ReleaseObjectArgs) UnmarshalJSON(b []byte) error {
	type Copy ReleaseObjectArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ReleaseObjectArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ReleaseObject in the Runtime domain.
func (a *ReleaseObjectArgs) MarshalJSON() ([]byte, error) {
	type Copy ReleaseObjectArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ReleaseObjectReply represents the return values for ReleaseObject in the Runtime domain.
type ReleaseObjectReply struct {
}

// ReleaseObjectReply returns whether or not the FrameID matches the reply value for ReleaseObject in the Runtime domain.
func (a *ReleaseObjectReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ReleaseObjectReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for ReleaseObject in the Runtime domain.
func (a *ReleaseObjectReply) UnmarshalJSON(b []byte) error {
	type Copy ReleaseObjectReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ReleaseObjectReply(*c)
	return nil
}

// ReleaseObjectGroupArgs represents the arguments for ReleaseObjectGroup in the Runtime domain.
type ReleaseObjectGroupArgs struct {
	ObjectGroup string `json:"objectGroup"` // Symbolic object group name.
}

// Unmarshal the byte array into a return value for ReleaseObjectGroup in the Runtime domain.
func (a *ReleaseObjectGroupArgs) UnmarshalJSON(b []byte) error {
	type Copy ReleaseObjectGroupArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ReleaseObjectGroupArgs(*c)
	return nil
}

// Marshall the byte array into a return value for ReleaseObjectGroup in the Runtime domain.
func (a *ReleaseObjectGroupArgs) MarshalJSON() ([]byte, error) {
	type Copy ReleaseObjectGroupArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// ReleaseObjectGroupReply represents the return values for ReleaseObjectGroup in the Runtime domain.
type ReleaseObjectGroupReply struct {
}

// ReleaseObjectGroupReply returns whether or not the FrameID matches the reply value for ReleaseObjectGroup in the Runtime domain.
func (a *ReleaseObjectGroupReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: ReleaseObjectGroupReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for ReleaseObjectGroup in the Runtime domain.
func (a *ReleaseObjectGroupReply) UnmarshalJSON(b []byte) error {
	type Copy ReleaseObjectGroupReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = ReleaseObjectGroupReply(*c)
	return nil
}

// RunIfWaitingForDebuggerArgs represents the arguments for RunIfWaitingForDebugger in the Runtime domain.
type RunIfWaitingForDebuggerArgs struct {
}

// Unmarshal the byte array into a return value for RunIfWaitingForDebugger in the Runtime domain.
func (a *RunIfWaitingForDebuggerArgs) UnmarshalJSON(b []byte) error {
	type Copy RunIfWaitingForDebuggerArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RunIfWaitingForDebuggerArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RunIfWaitingForDebugger in the Runtime domain.
func (a *RunIfWaitingForDebuggerArgs) MarshalJSON() ([]byte, error) {
	type Copy RunIfWaitingForDebuggerArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RunIfWaitingForDebuggerReply represents the return values for RunIfWaitingForDebugger in the Runtime domain.
type RunIfWaitingForDebuggerReply struct {
}

// RunIfWaitingForDebuggerReply returns whether or not the FrameID matches the reply value for RunIfWaitingForDebugger in the Runtime domain.
func (a *RunIfWaitingForDebuggerReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RunIfWaitingForDebuggerReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for RunIfWaitingForDebugger in the Runtime domain.
func (a *RunIfWaitingForDebuggerReply) UnmarshalJSON(b []byte) error {
	type Copy RunIfWaitingForDebuggerReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RunIfWaitingForDebuggerReply(*c)
	return nil
}

// RunScriptArgs represents the arguments for RunScript in the Runtime domain.
type RunScriptArgs struct {
	ScriptID              ScriptID           `json:"scriptId"`                        // Id of the script to run.
	ExecutionContextID    ExecutionContextID `json:"executionContextId,omitempty"`    // Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
	ObjectGroup           string             `json:"objectGroup,omitempty"`           // Symbolic group name that can be used to release multiple objects.
	Silent                bool               `json:"silent,omitempty"`                // In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides `setPauseOnException` state.
	IncludeCommandLineAPI bool               `json:"includeCommandLineAPI,omitempty"` // Determines whether Command Line API should be available during the evaluation.
	ReturnByValue         bool               `json:"returnByValue,omitempty"`         // Whether the result is expected to be a JSON object which should be sent by value.
	GeneratePreview       bool               `json:"generatePreview,omitempty"`       // Whether preview should be generated for the result.
	AwaitPromise          bool               `json:"awaitPromise,omitempty"`          // Whether execution should `await` for resulting value and return once awaited promise is resolved.
}

// Unmarshal the byte array into a return value for RunScript in the Runtime domain.
func (a *RunScriptArgs) UnmarshalJSON(b []byte) error {
	type Copy RunScriptArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RunScriptArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RunScript in the Runtime domain.
func (a *RunScriptArgs) MarshalJSON() ([]byte, error) {
	type Copy RunScriptArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RunScriptReply represents the return values for RunScript in the Runtime domain.
type RunScriptReply struct {
	Result           RemoteObject     `json:"result"`                     // Run result.
	ExceptionDetails ExceptionDetails `json:"exceptionDetails,omitempty"` // Exception details.
}

// RunScriptReply returns whether or not the FrameID matches the reply value for RunScript in the Runtime domain.
func (a *RunScriptReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RunScriptReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for RunScript in the Runtime domain.
func (a *RunScriptReply) UnmarshalJSON(b []byte) error {
	type Copy RunScriptReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RunScriptReply(*c)
	return nil
}

// SetCustomObjectFormatterEnabledArgs represents the arguments for SetCustomObjectFormatterEnabled in the Runtime domain.
type SetCustomObjectFormatterEnabledArgs struct {
	Enabled bool `json:"enabled"` // No description.
}

// Unmarshal the byte array into a return value for SetCustomObjectFormatterEnabled in the Runtime domain.
func (a *SetCustomObjectFormatterEnabledArgs) UnmarshalJSON(b []byte) error {
	type Copy SetCustomObjectFormatterEnabledArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCustomObjectFormatterEnabledArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetCustomObjectFormatterEnabled in the Runtime domain.
func (a *SetCustomObjectFormatterEnabledArgs) MarshalJSON() ([]byte, error) {
	type Copy SetCustomObjectFormatterEnabledArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetCustomObjectFormatterEnabledReply represents the return values for SetCustomObjectFormatterEnabled in the Runtime domain.
type SetCustomObjectFormatterEnabledReply struct {
}

// SetCustomObjectFormatterEnabledReply returns whether or not the FrameID matches the reply value for SetCustomObjectFormatterEnabled in the Runtime domain.
func (a *SetCustomObjectFormatterEnabledReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetCustomObjectFormatterEnabledReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetCustomObjectFormatterEnabled in the Runtime domain.
func (a *SetCustomObjectFormatterEnabledReply) UnmarshalJSON(b []byte) error {
	type Copy SetCustomObjectFormatterEnabledReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetCustomObjectFormatterEnabledReply(*c)
	return nil
}

// SetMaxCallStackSizeToCaptureArgs represents the arguments for SetMaxCallStackSizeToCapture in the Runtime domain.
type SetMaxCallStackSizeToCaptureArgs struct {
	Size int `json:"size"` // No description.
}

// Unmarshal the byte array into a return value for SetMaxCallStackSizeToCapture in the Runtime domain.
func (a *SetMaxCallStackSizeToCaptureArgs) UnmarshalJSON(b []byte) error {
	type Copy SetMaxCallStackSizeToCaptureArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetMaxCallStackSizeToCaptureArgs(*c)
	return nil
}

// Marshall the byte array into a return value for SetMaxCallStackSizeToCapture in the Runtime domain.
func (a *SetMaxCallStackSizeToCaptureArgs) MarshalJSON() ([]byte, error) {
	type Copy SetMaxCallStackSizeToCaptureArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// SetMaxCallStackSizeToCaptureReply represents the return values for SetMaxCallStackSizeToCapture in the Runtime domain.
type SetMaxCallStackSizeToCaptureReply struct {
}

// SetMaxCallStackSizeToCaptureReply returns whether or not the FrameID matches the reply value for SetMaxCallStackSizeToCapture in the Runtime domain.
func (a *SetMaxCallStackSizeToCaptureReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: SetMaxCallStackSizeToCaptureReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for SetMaxCallStackSizeToCapture in the Runtime domain.
func (a *SetMaxCallStackSizeToCaptureReply) UnmarshalJSON(b []byte) error {
	type Copy SetMaxCallStackSizeToCaptureReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = SetMaxCallStackSizeToCaptureReply(*c)
	return nil
}

// TerminateExecutionArgs represents the arguments for TerminateExecution in the Runtime domain.
type TerminateExecutionArgs struct {
}

// Unmarshal the byte array into a return value for TerminateExecution in the Runtime domain.
func (a *TerminateExecutionArgs) UnmarshalJSON(b []byte) error {
	type Copy TerminateExecutionArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = TerminateExecutionArgs(*c)
	return nil
}

// Marshall the byte array into a return value for TerminateExecution in the Runtime domain.
func (a *TerminateExecutionArgs) MarshalJSON() ([]byte, error) {
	type Copy TerminateExecutionArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// TerminateExecutionReply represents the return values for TerminateExecution in the Runtime domain.
type TerminateExecutionReply struct {
}

// TerminateExecutionReply returns whether or not the FrameID matches the reply value for TerminateExecution in the Runtime domain.
func (a *TerminateExecutionReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: TerminateExecutionReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for TerminateExecution in the Runtime domain.
func (a *TerminateExecutionReply) UnmarshalJSON(b []byte) error {
	type Copy TerminateExecutionReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = TerminateExecutionReply(*c)
	return nil
}

// AddBindingArgs represents the arguments for AddBinding in the Runtime domain.
type AddBindingArgs struct {
	Name               string             `json:"name"`                         // No description.
	ExecutionContextID ExecutionContextID `json:"executionContextId,omitempty"` // No description.
}

// Unmarshal the byte array into a return value for AddBinding in the Runtime domain.
func (a *AddBindingArgs) UnmarshalJSON(b []byte) error {
	type Copy AddBindingArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = AddBindingArgs(*c)
	return nil
}

// Marshall the byte array into a return value for AddBinding in the Runtime domain.
func (a *AddBindingArgs) MarshalJSON() ([]byte, error) {
	type Copy AddBindingArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// AddBindingReply represents the return values for AddBinding in the Runtime domain.
type AddBindingReply struct {
}

// AddBindingReply returns whether or not the FrameID matches the reply value for AddBinding in the Runtime domain.
func (a *AddBindingReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: AddBindingReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for AddBinding in the Runtime domain.
func (a *AddBindingReply) UnmarshalJSON(b []byte) error {
	type Copy AddBindingReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = AddBindingReply(*c)
	return nil
}

// RemoveBindingArgs represents the arguments for RemoveBinding in the Runtime domain.
type RemoveBindingArgs struct {
	Name string `json:"name"` // No description.
}

// Unmarshal the byte array into a return value for RemoveBinding in the Runtime domain.
func (a *RemoveBindingArgs) UnmarshalJSON(b []byte) error {
	type Copy RemoveBindingArgs
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RemoveBindingArgs(*c)
	return nil
}

// Marshall the byte array into a return value for RemoveBinding in the Runtime domain.
func (a *RemoveBindingArgs) MarshalJSON() ([]byte, error) {
	type Copy RemoveBindingArgs
	c := &Copy{}
	*c = Copy(*a)
	return json.Marshal(&c)
}

// RemoveBindingReply represents the return values for RemoveBinding in the Runtime domain.
type RemoveBindingReply struct {
}

// RemoveBindingReply returns whether or not the FrameID matches the reply value for RemoveBinding in the Runtime domain.
func (a *RemoveBindingReply) MatchFrameID(frameID string, m []byte) bool {
	err := a.UnmarshalJSON(m)
	if err != nil {
		log.Fatalf("unmarshal error: RemoveBindingReply", err)
	}
	return true
}

// Unmarshal the byte array into a return value for RemoveBinding in the Runtime domain.
func (a *RemoveBindingReply) UnmarshalJSON(b []byte) error {
	type Copy RemoveBindingReply
	c := &Copy{}
	err := json.Unmarshal(b, c)
	if err != nil {
		return err
	}
	*a = RemoveBindingReply(*c)
	return nil
}
